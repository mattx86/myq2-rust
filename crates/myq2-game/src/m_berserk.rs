// m_berserk.rs â€” Berserk monster
// Converted from: myq2-original/game/m_berserk.c
// Frame definitions from: myq2-original/game/m_berserk.h

use crate::g_local::*;
use crate::game::*;
use crate::entity_adapters::{gi_sound, gi_soundindex, gi_modelindex, gi_linkentity, throw_gib, throw_head, walkmonster_start, g_free_edict, fire_hit};
use crate::game_import::skill_value;
use myq2_common::common::{frand as random, rand_i32};

// ============================================================
// Frame definitions (from m_berserk.h)
// This file generated by ModelGen - Do NOT Modify
// ============================================================

pub const FRAME_STAND1: i32 = 0;
pub const FRAME_STAND2: i32 = 1;
pub const FRAME_STAND3: i32 = 2;
pub const FRAME_STAND4: i32 = 3;
pub const FRAME_STAND5: i32 = 4;
pub const FRAME_STANDB1: i32 = 5;
pub const FRAME_STANDB2: i32 = 6;
pub const FRAME_STANDB3: i32 = 7;
pub const FRAME_STANDB4: i32 = 8;
pub const FRAME_STANDB5: i32 = 9;
pub const FRAME_STANDB6: i32 = 10;
pub const FRAME_STANDB7: i32 = 11;
pub const FRAME_STANDB8: i32 = 12;
pub const FRAME_STANDB9: i32 = 13;
pub const FRAME_STANDB10: i32 = 14;
pub const FRAME_STANDB11: i32 = 15;
pub const FRAME_STANDB12: i32 = 16;
pub const FRAME_STANDB13: i32 = 17;
pub const FRAME_STANDB14: i32 = 18;
pub const FRAME_STANDB15: i32 = 19;
pub const FRAME_STANDB16: i32 = 20;
pub const FRAME_STANDB17: i32 = 21;
pub const FRAME_STANDB18: i32 = 22;
pub const FRAME_STANDB19: i32 = 23;
pub const FRAME_STANDB20: i32 = 24;
pub const FRAME_WALKC1: i32 = 25;
pub const FRAME_WALKC2: i32 = 26;
pub const FRAME_WALKC3: i32 = 27;
pub const FRAME_WALKC4: i32 = 28;
pub const FRAME_WALKC5: i32 = 29;
pub const FRAME_WALKC6: i32 = 30;
pub const FRAME_WALKC7: i32 = 31;
pub const FRAME_WALKC8: i32 = 32;
pub const FRAME_WALKC9: i32 = 33;
pub const FRAME_WALKC10: i32 = 34;
pub const FRAME_WALKC11: i32 = 35;
pub const FRAME_RUN1: i32 = 36;
pub const FRAME_RUN2: i32 = 37;
pub const FRAME_RUN3: i32 = 38;
pub const FRAME_RUN4: i32 = 39;
pub const FRAME_RUN5: i32 = 40;
pub const FRAME_RUN6: i32 = 41;
pub const FRAME_ATT_A1: i32 = 42;
pub const FRAME_ATT_A2: i32 = 43;
pub const FRAME_ATT_A3: i32 = 44;
pub const FRAME_ATT_A4: i32 = 45;
pub const FRAME_ATT_A5: i32 = 46;
pub const FRAME_ATT_A6: i32 = 47;
pub const FRAME_ATT_A7: i32 = 48;
pub const FRAME_ATT_A8: i32 = 49;
pub const FRAME_ATT_A9: i32 = 50;
pub const FRAME_ATT_A10: i32 = 51;
pub const FRAME_ATT_A11: i32 = 52;
pub const FRAME_ATT_A12: i32 = 53;
pub const FRAME_ATT_A13: i32 = 54;
pub const FRAME_ATT_B1: i32 = 55;
pub const FRAME_ATT_B2: i32 = 56;
pub const FRAME_ATT_B3: i32 = 57;
pub const FRAME_ATT_B4: i32 = 58;
pub const FRAME_ATT_B5: i32 = 59;
pub const FRAME_ATT_B6: i32 = 60;
pub const FRAME_ATT_B7: i32 = 61;
pub const FRAME_ATT_B8: i32 = 62;
pub const FRAME_ATT_B9: i32 = 63;
pub const FRAME_ATT_B10: i32 = 64;
pub const FRAME_ATT_B11: i32 = 65;
pub const FRAME_ATT_B12: i32 = 66;
pub const FRAME_ATT_B13: i32 = 67;
pub const FRAME_ATT_B14: i32 = 68;
pub const FRAME_ATT_B15: i32 = 69;
pub const FRAME_ATT_B16: i32 = 70;
pub const FRAME_ATT_B17: i32 = 71;
pub const FRAME_ATT_B18: i32 = 72;
pub const FRAME_ATT_B19: i32 = 73;
pub const FRAME_ATT_B20: i32 = 74;
pub const FRAME_ATT_B21: i32 = 75;
pub const FRAME_ATT_C1: i32 = 76;
pub const FRAME_ATT_C2: i32 = 77;
pub const FRAME_ATT_C3: i32 = 78;
pub const FRAME_ATT_C4: i32 = 79;
pub const FRAME_ATT_C5: i32 = 80;
pub const FRAME_ATT_C6: i32 = 81;
pub const FRAME_ATT_C7: i32 = 82;
pub const FRAME_ATT_C8: i32 = 83;
pub const FRAME_ATT_C9: i32 = 84;
pub const FRAME_ATT_C10: i32 = 85;
pub const FRAME_ATT_C11: i32 = 86;
pub const FRAME_ATT_C12: i32 = 87;
pub const FRAME_ATT_C13: i32 = 88;
pub const FRAME_ATT_C14: i32 = 89;
pub const FRAME_ATT_C15: i32 = 90;
pub const FRAME_ATT_C16: i32 = 91;
pub const FRAME_ATT_C17: i32 = 92;
pub const FRAME_ATT_C18: i32 = 93;
pub const FRAME_ATT_C19: i32 = 94;
pub const FRAME_ATT_C20: i32 = 95;
pub const FRAME_ATT_C21: i32 = 96;
pub const FRAME_ATT_C22: i32 = 97;
pub const FRAME_ATT_C23: i32 = 98;
pub const FRAME_ATT_C24: i32 = 99;
pub const FRAME_ATT_C25: i32 = 100;
pub const FRAME_ATT_C26: i32 = 101;
pub const FRAME_ATT_C27: i32 = 102;
pub const FRAME_ATT_C28: i32 = 103;
pub const FRAME_ATT_C29: i32 = 104;
pub const FRAME_ATT_C30: i32 = 105;
pub const FRAME_ATT_C31: i32 = 106;
pub const FRAME_ATT_C32: i32 = 107;
pub const FRAME_ATT_C33: i32 = 108;
pub const FRAME_ATT_C34: i32 = 109;
pub const FRAME_R_ATT1: i32 = 110;
pub const FRAME_R_ATT2: i32 = 111;
pub const FRAME_R_ATT3: i32 = 112;
pub const FRAME_R_ATT4: i32 = 113;
pub const FRAME_R_ATT5: i32 = 114;
pub const FRAME_R_ATT6: i32 = 115;
pub const FRAME_R_ATT7: i32 = 116;
pub const FRAME_R_ATT8: i32 = 117;
pub const FRAME_R_ATT9: i32 = 118;
pub const FRAME_R_ATT10: i32 = 119;
pub const FRAME_R_ATT11: i32 = 120;
pub const FRAME_R_ATT12: i32 = 121;
pub const FRAME_R_ATT13: i32 = 122;
pub const FRAME_R_ATT14: i32 = 123;
pub const FRAME_R_ATT15: i32 = 124;
pub const FRAME_R_ATT16: i32 = 125;
pub const FRAME_R_ATT17: i32 = 126;
pub const FRAME_R_ATT18: i32 = 127;
pub const FRAME_R_ATTB1: i32 = 128;
pub const FRAME_R_ATTB2: i32 = 129;
pub const FRAME_R_ATTB3: i32 = 130;
pub const FRAME_R_ATTB4: i32 = 131;
pub const FRAME_R_ATTB5: i32 = 132;
pub const FRAME_R_ATTB6: i32 = 133;
pub const FRAME_R_ATTB7: i32 = 134;
pub const FRAME_R_ATTB8: i32 = 135;
pub const FRAME_R_ATTB9: i32 = 136;
pub const FRAME_R_ATTB10: i32 = 137;
pub const FRAME_R_ATTB11: i32 = 138;
pub const FRAME_R_ATTB12: i32 = 139;
pub const FRAME_R_ATTB13: i32 = 140;
pub const FRAME_R_ATTB14: i32 = 141;
pub const FRAME_R_ATTB15: i32 = 142;
pub const FRAME_R_ATTB16: i32 = 143;
pub const FRAME_R_ATTB17: i32 = 144;
pub const FRAME_R_ATTB18: i32 = 145;
pub const FRAME_SLAM1: i32 = 146;
pub const FRAME_SLAM2: i32 = 147;
pub const FRAME_SLAM3: i32 = 148;
pub const FRAME_SLAM4: i32 = 149;
pub const FRAME_SLAM5: i32 = 150;
pub const FRAME_SLAM6: i32 = 151;
pub const FRAME_SLAM7: i32 = 152;
pub const FRAME_SLAM8: i32 = 153;
pub const FRAME_SLAM9: i32 = 154;
pub const FRAME_SLAM10: i32 = 155;
pub const FRAME_SLAM11: i32 = 156;
pub const FRAME_SLAM12: i32 = 157;
pub const FRAME_SLAM13: i32 = 158;
pub const FRAME_SLAM14: i32 = 159;
pub const FRAME_SLAM15: i32 = 160;
pub const FRAME_SLAM16: i32 = 161;
pub const FRAME_SLAM17: i32 = 162;
pub const FRAME_SLAM18: i32 = 163;
pub const FRAME_SLAM19: i32 = 164;
pub const FRAME_SLAM20: i32 = 165;
pub const FRAME_SLAM21: i32 = 166;
pub const FRAME_SLAM22: i32 = 167;
pub const FRAME_SLAM23: i32 = 168;
pub const FRAME_DUCK1: i32 = 169;
pub const FRAME_DUCK2: i32 = 170;
pub const FRAME_DUCK3: i32 = 171;
pub const FRAME_DUCK4: i32 = 172;
pub const FRAME_DUCK5: i32 = 173;
pub const FRAME_DUCK6: i32 = 174;
pub const FRAME_DUCK7: i32 = 175;
pub const FRAME_DUCK8: i32 = 176;
pub const FRAME_DUCK9: i32 = 177;
pub const FRAME_DUCK10: i32 = 178;
pub const FRAME_FALL1: i32 = 179;
pub const FRAME_FALL2: i32 = 180;
pub const FRAME_FALL3: i32 = 181;
pub const FRAME_FALL4: i32 = 182;
pub const FRAME_FALL5: i32 = 183;
pub const FRAME_FALL6: i32 = 184;
pub const FRAME_FALL7: i32 = 185;
pub const FRAME_FALL8: i32 = 186;
pub const FRAME_FALL9: i32 = 187;
pub const FRAME_FALL10: i32 = 188;
pub const FRAME_FALL11: i32 = 189;
pub const FRAME_FALL12: i32 = 190;
pub const FRAME_FALL13: i32 = 191;
pub const FRAME_FALL14: i32 = 192;
pub const FRAME_FALL15: i32 = 193;
pub const FRAME_FALL16: i32 = 194;
pub const FRAME_FALL17: i32 = 195;
pub const FRAME_FALL18: i32 = 196;
pub const FRAME_FALL19: i32 = 197;
pub const FRAME_FALL20: i32 = 198;
pub const FRAME_PAINC1: i32 = 199;
pub const FRAME_PAINC2: i32 = 200;
pub const FRAME_PAINC3: i32 = 201;
pub const FRAME_PAINC4: i32 = 202;
pub const FRAME_PAINB1: i32 = 203;
pub const FRAME_PAINB2: i32 = 204;
pub const FRAME_PAINB3: i32 = 205;
pub const FRAME_PAINB4: i32 = 206;
pub const FRAME_PAINB5: i32 = 207;
pub const FRAME_PAINB6: i32 = 208;
pub const FRAME_PAINB7: i32 = 209;
pub const FRAME_PAINB8: i32 = 210;
pub const FRAME_PAINB9: i32 = 211;
pub const FRAME_PAINB10: i32 = 212;
pub const FRAME_PAINB11: i32 = 213;
pub const FRAME_PAINB12: i32 = 214;
pub const FRAME_PAINB13: i32 = 215;
pub const FRAME_PAINB14: i32 = 216;
pub const FRAME_PAINB15: i32 = 217;
pub const FRAME_PAINB16: i32 = 218;
pub const FRAME_PAINB17: i32 = 219;
pub const FRAME_PAINB18: i32 = 220;
pub const FRAME_PAINB19: i32 = 221;
pub const FRAME_PAINB20: i32 = 222;
pub const FRAME_DEATH1: i32 = 223;
pub const FRAME_DEATH2: i32 = 224;
pub const FRAME_DEATH3: i32 = 225;
pub const FRAME_DEATH4: i32 = 226;
pub const FRAME_DEATH5: i32 = 227;
pub const FRAME_DEATH6: i32 = 228;
pub const FRAME_DEATH7: i32 = 229;
pub const FRAME_DEATH8: i32 = 230;
pub const FRAME_DEATH9: i32 = 231;
pub const FRAME_DEATH10: i32 = 232;
pub const FRAME_DEATH11: i32 = 233;
pub const FRAME_DEATH12: i32 = 234;
pub const FRAME_DEATH13: i32 = 235;
pub const FRAME_DEATHC1: i32 = 236;
pub const FRAME_DEATHC2: i32 = 237;
pub const FRAME_DEATHC3: i32 = 238;
pub const FRAME_DEATHC4: i32 = 239;
pub const FRAME_DEATHC5: i32 = 240;
pub const FRAME_DEATHC6: i32 = 241;
pub const FRAME_DEATHC7: i32 = 242;
pub const FRAME_DEATHC8: i32 = 243;

pub const MODEL_SCALE: f32 = 1.0;

// ============================================================
// Sound channel / attenuation constants (mirrors C defines)
// ============================================================

// CHAN_*, ATTN_* come from g_local::* re-export (myq2_common::q_shared)

// ============================================================
// Animation frame type and move type
// ============================================================


use crate::ai_wrappers::{ai_stand, ai_walk, ai_run, ai_charge, ai_move};

// ============================================================
// Sound indices (module-level state, replaces C statics)
// ============================================================

#[derive(Default)]
pub struct BerserkSounds {
    pub pain: i32,
    pub die: i32,
    pub idle: i32,
    pub punch: i32,
    pub sight: i32,
    pub search: i32,
}

static SOUNDS: std::sync::OnceLock<BerserkSounds> = std::sync::OnceLock::new();


// ============================================================
// Berserk behavior functions
// ============================================================

pub fn berserk_sight(self_ent: &mut Edict, _other: &mut Edict) {
    let sound_sight = SOUNDS.get().map_or(0, |s| s.sight);
    gi_sound(self_ent, CHAN_VOICE, sound_sight, 1.0, ATTN_NORM, 0.0);
}

pub fn berserk_search(self_ent: &mut Edict) {
    let sound_search = SOUNDS.get().map_or(0, |s| s.search);
    gi_sound(self_ent, CHAN_VOICE, sound_search, 1.0, ATTN_NORM, 0.0);
}

// ============================================================
// Stand animation
// ============================================================

fn berserk_fidget(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        return;
    }
    if random() > 0.15 {
        return;
    }

    self_ent.monsterinfo.currentmove = Some(MOVE_STAND_FIDGET);
    let sound_idle = SOUNDS.get().map_or(0, |s| s.idle);
    gi_sound(self_ent, CHAN_WEAPON, sound_idle, 1.0, ATTN_IDLE, 0.0);
}

static BERSERK_FRAMES_STAND: [MFrame; 5] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(berserk_fidget) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static BERSERK_MOVE_STAND: MMove = MMove {
    firstframe: FRAME_STAND1,
    lastframe: FRAME_STAND5,
    frames: &BERSERK_FRAMES_STAND,
    endfunc: None,
};

/// Index constants for move table references via monsterinfo.currentmove
pub const MOVE_STAND: usize = 0;
pub const MOVE_STAND_FIDGET: usize = 1;
pub const MOVE_WALK: usize = 2;
pub const MOVE_RUN1: usize = 3;
pub const MOVE_ATTACK_SPIKE: usize = 4;
pub const MOVE_ATTACK_CLUB: usize = 5;
pub const MOVE_ATTACK_STRIKE: usize = 6;
pub const MOVE_PAIN1: usize = 7;
pub const MOVE_PAIN2: usize = 8;
pub const MOVE_DEATH1: usize = 9;
pub const MOVE_DEATH2: usize = 10;

pub fn berserk_stand(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
}

// ============================================================
// Stand fidget animation
// ============================================================

static BERSERK_FRAMES_STAND_FIDGET: [MFrame; 20] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static BERSERK_MOVE_STAND_FIDGET: MMove = MMove {
    firstframe: FRAME_STANDB1,
    lastframe: FRAME_STANDB20,
    frames: &BERSERK_FRAMES_STAND_FIDGET,
    endfunc: Some(berserk_stand),
};

// ============================================================
// Walk animation
// ============================================================

static BERSERK_FRAMES_WALK: [MFrame; 11] = [
    MFrame { ai_fn: ai_walk, dist: 9.1, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.3, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.9, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.7, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.2, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 7.2, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.1, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.9, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.7, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.7, think_fn: None },
];

pub static BERSERK_MOVE_WALK: MMove = MMove {
    firstframe: FRAME_WALKC1,
    lastframe: FRAME_WALKC11,
    frames: &BERSERK_FRAMES_WALK,
    endfunc: None,
};

pub fn berserk_walk(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_WALK);
}

// ============================================================
// Run animation
// ============================================================

static BERSERK_FRAMES_RUN1: [MFrame; 6] = [
    MFrame { ai_fn: ai_run, dist: 21.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 11.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 21.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 25.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 18.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 19.0, think_fn: None },
];

pub static BERSERK_MOVE_RUN1: MMove = MMove {
    firstframe: FRAME_RUN1,
    lastframe: FRAME_RUN6,
    frames: &BERSERK_FRAMES_RUN1,
    endfunc: None,
};

pub fn berserk_run(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_RUN1);
    }
}

// ============================================================
// Attack: spike
// ============================================================

fn berserk_attack_spike(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let aim: [f32; 3] = [MELEE_DISTANCE, 0.0, -24.0];
    fire_hit(self_ent, &aim, 15 + (rand_i32() % 6), 400); // Faster attack -- upwards and backwards
}

fn berserk_swing(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_punch = SOUNDS.get().map_or(0, |s| s.punch);
    gi_sound(self_ent, CHAN_WEAPON, sound_punch, 1.0, ATTN_NORM, 0.0);
}

static BERSERK_FRAMES_ATTACK_SPIKE: [MFrame; 8] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(berserk_swing) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(berserk_attack_spike) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
];

pub static BERSERK_MOVE_ATTACK_SPIKE: MMove = MMove {
    firstframe: FRAME_ATT_C1,
    lastframe: FRAME_ATT_C8,
    frames: &BERSERK_FRAMES_ATTACK_SPIKE,
    endfunc: Some(berserk_run),
};

// ============================================================
// Attack: club
// ============================================================

fn berserk_attack_club(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let aim: [f32; 3] = [MELEE_DISTANCE, self_ent.mins[0], -4.0];
    fire_hit(self_ent, &aim, 5 + (rand_i32() % 6), 400); // Slower attack
}

static BERSERK_FRAMES_ATTACK_CLUB: [MFrame; 12] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(berserk_swing) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(berserk_attack_club) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
];

pub static BERSERK_MOVE_ATTACK_CLUB: MMove = MMove {
    firstframe: FRAME_ATT_C9,
    lastframe: FRAME_ATT_C20,
    frames: &BERSERK_FRAMES_ATTACK_CLUB,
    endfunc: Some(berserk_run),
};

// ============================================================
// Attack: strike
// ============================================================

fn berserk_strike(_self_ent: &mut Edict, _ctx: &mut GameContext) {
    // Impact sound not implemented in original Q2
}

static BERSERK_FRAMES_ATTACK_STRIKE: [MFrame; 14] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(berserk_swing) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(berserk_strike) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 9.7, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 13.6, think_fn: None },
];

pub static BERSERK_MOVE_ATTACK_STRIKE: MMove = MMove {
    firstframe: FRAME_ATT_C21,
    lastframe: FRAME_ATT_C34,
    frames: &BERSERK_FRAMES_ATTACK_STRIKE,
    endfunc: Some(berserk_run),
};

// ============================================================
// Melee (randomly picks spike or club)
// ============================================================

pub fn berserk_melee(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if (rand_i32() % 2) == 0 {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_SPIKE);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_CLUB);
    }
}

// ============================================================
// Pain animations
// ============================================================

static BERSERK_FRAMES_PAIN1: [MFrame; 4] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static BERSERK_MOVE_PAIN1: MMove = MMove {
    firstframe: FRAME_PAINC1,
    lastframe: FRAME_PAINC4,
    frames: &BERSERK_FRAMES_PAIN1,
    endfunc: Some(berserk_run),
};

static BERSERK_FRAMES_PAIN2: [MFrame; 20] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static BERSERK_MOVE_PAIN2: MMove = MMove {
    firstframe: FRAME_PAINB1,
    lastframe: FRAME_PAINB20,
    frames: &BERSERK_FRAMES_PAIN2,
    endfunc: Some(berserk_run),
};

pub fn berserk_pain(self_ent: &mut Edict, _other: &mut Edict, _kick: f32, damage: i32, ctx: &mut GameContext) {
    if self_ent.health < (self_ent.max_health / 2) {
        self_ent.s.skinnum = 1;
    }

    if ctx.level.time < self_ent.pain_debounce_time {
        return;
    }

    self_ent.pain_debounce_time = ctx.level.time + 3.0;
    let sound_pain = SOUNDS.get().map_or(0, |s| s.pain);
    gi_sound(self_ent, CHAN_VOICE, sound_pain, 1.0, ATTN_NORM, 0.0);

    // skill->value == 3 means nightmare: no pain anims
    if skill_value() == 3.0 {
        return; // no pain anims in nightmare
    }

    if (damage < 20) || (random() < 0.5) {
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN1);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN2);
    }
}

// ============================================================
// Death
// ============================================================

fn berserk_dead(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.mins = [-16.0, -16.0, -24.0];
    self_ent.maxs = [16.0, 16.0, -8.0];
    self_ent.movetype = MoveType::Toss;
    self_ent.svflags |= SVF_DEADMONSTER;
    self_ent.nextthink = 0.0;
    gi_linkentity(self_ent);
}

static BERSERK_FRAMES_DEATH1: [MFrame; 13] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static BERSERK_MOVE_DEATH1: MMove = MMove {
    firstframe: FRAME_DEATH1,
    lastframe: FRAME_DEATH13,
    frames: &BERSERK_FRAMES_DEATH1,
    endfunc: Some(berserk_dead),
};

static BERSERK_FRAMES_DEATH2: [MFrame; 8] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static BERSERK_MOVE_DEATH2: MMove = MMove {
    firstframe: FRAME_DEATHC1,
    lastframe: FRAME_DEATHC8,
    frames: &BERSERK_FRAMES_DEATH2,
    endfunc: Some(berserk_dead),
};

pub fn berserk_die(self_ent: &mut Edict, _inflictor: &mut Edict, _attacker: &mut Edict, damage: i32, _point: [f32; 3], _ctx: &mut GameContext) {
    if self_ent.health <= self_ent.gib_health {
        gi_sound(self_ent, CHAN_VOICE, gi_soundindex("misc/udeath.wav"), 1.0, ATTN_NORM, 0.0);
        for _ in 0..2 {
            throw_gib(self_ent, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
        }
        for _ in 0..4 {
            throw_gib(self_ent, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
        }
        throw_head(self_ent, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
        self_ent.deadflag = DEAD_DEAD;
        return;
    }

    if self_ent.deadflag == DEAD_DEAD {
        return;
    }

    let sound_die = SOUNDS.get().map_or(0, |s| s.die);
    gi_sound(self_ent, CHAN_VOICE, sound_die, 1.0, ATTN_NORM, 0.0);
    self_ent.deadflag = DEAD_DEAD;
    self_ent.takedamage = Damage::Yes as i32;

    if damage >= 50 {
        self_ent.monsterinfo.currentmove = Some(MOVE_DEATH1);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_DEATH2);
    }
}

// ============================================================
// Spawn function
// ============================================================

/// QUAKED monster_berserk (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
pub fn sp_monster_berserk(self_ent: &mut Edict, ctx: &mut GameContext) {
    if ctx.deathmatch != 0.0 {
        g_free_edict(self_ent);
        return;
    }

    // Pre-caches
    SOUNDS.get_or_init(|| BerserkSounds {
        pain: gi_soundindex("berserk/berpain2.wav"),
        die: gi_soundindex("berserk/berdeth2.wav"),
        idle: gi_soundindex("berserk/beridle1.wav"),
        punch: gi_soundindex("berserk/attack.wav"),
        search: gi_soundindex("berserk/bersrch1.wav"),
        sight: gi_soundindex("berserk/sight.wav"),
    });

    self_ent.s.modelindex = gi_modelindex("models/monsters/berserk/tris.md2");
    self_ent.mins = [-16.0, -16.0, -24.0];
    self_ent.maxs = [16.0, 16.0, 32.0];
    self_ent.movetype = MoveType::Step;
    self_ent.solid = Solid::Bbox;

    self_ent.health = 240;
    self_ent.gib_health = -60;
    self_ent.mass = 250;

    // Function callbacks stored as indices into dispatch tables
    // pain_fn and die_fn will be resolved by the dispatch system
    // For now we store sentinel indices that identify berserk handlers
    self_ent.pain_fn = Some(crate::dispatch::PAIN_BERSERK);
    self_ent.die_fn = Some(crate::dispatch::DIE_BERSERK);

    self_ent.monsterinfo.stand_fn = Some(crate::dispatch::MSTAND_BERSERK);
    self_ent.monsterinfo.walk_fn = Some(crate::dispatch::MWALK_BERSERK);
    self_ent.monsterinfo.run_fn = Some(crate::dispatch::MRUN_BERSERK);
    self_ent.monsterinfo.dodge_fn = None;
    self_ent.monsterinfo.attack_fn = None;
    self_ent.monsterinfo.melee_fn = Some(crate::dispatch::MMELEE_BERSERK);
    self_ent.monsterinfo.sight_fn = Some(crate::dispatch::MSIGHT_BERSERK);
    self_ent.monsterinfo.search_fn = None;  // berserk_search exists but no MSEARCH_BERSERK constant

    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    self_ent.monsterinfo.scale = MODEL_SCALE;

    gi_linkentity(self_ent);

    walkmonster_start(self_ent);
}

// ============================================================
// Move table: maps move indices to MMove statics
// ============================================================

/// Returns the MMove for a given berserk move index.
pub fn berserk_get_move(index: usize) -> Option<&'static MMove> {
    match index {
        MOVE_STAND => Some(&BERSERK_MOVE_STAND),
        MOVE_STAND_FIDGET => Some(&BERSERK_MOVE_STAND_FIDGET),
        MOVE_WALK => Some(&BERSERK_MOVE_WALK),
        MOVE_RUN1 => Some(&BERSERK_MOVE_RUN1),
        MOVE_ATTACK_SPIKE => Some(&BERSERK_MOVE_ATTACK_SPIKE),
        MOVE_ATTACK_CLUB => Some(&BERSERK_MOVE_ATTACK_CLUB),
        MOVE_ATTACK_STRIKE => Some(&BERSERK_MOVE_ATTACK_STRIKE),
        MOVE_PAIN1 => Some(&BERSERK_MOVE_PAIN1),
        MOVE_PAIN2 => Some(&BERSERK_MOVE_PAIN2),
        MOVE_DEATH1 => Some(&BERSERK_MOVE_DEATH1),
        MOVE_DEATH2 => Some(&BERSERK_MOVE_DEATH2),
        _ => None,
    }
}
