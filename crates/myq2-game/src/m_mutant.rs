// m_mutant.rs â€” Mutant monster
// Converted from: myq2-original/game/m_mutant.c
// Frame definitions from: myq2-original/game/m_mutant.h

use crate::g_local::*;
use crate::game::*;
use myq2_common::common::{frand as random, rand_i32};
use myq2_common::q_shared::{vector_normalize, vector_length};

// ============================================================
// Frame definitions (from m_mutant.h)
// This file generated by ModelGen - Do NOT Modify
// ============================================================

pub const FRAME_ATTACK01: i32 = 0;
pub const FRAME_ATTACK02: i32 = 1;
pub const FRAME_ATTACK03: i32 = 2;
pub const FRAME_ATTACK04: i32 = 3;
pub const FRAME_ATTACK05: i32 = 4;
pub const FRAME_ATTACK06: i32 = 5;
pub const FRAME_ATTACK07: i32 = 6;
pub const FRAME_ATTACK08: i32 = 7;
pub const FRAME_ATTACK09: i32 = 8;
pub const FRAME_ATTACK10: i32 = 9;
pub const FRAME_ATTACK11: i32 = 10;
pub const FRAME_ATTACK12: i32 = 11;
pub const FRAME_ATTACK13: i32 = 12;
pub const FRAME_ATTACK14: i32 = 13;
pub const FRAME_ATTACK15: i32 = 14;
pub const FRAME_DEATH101: i32 = 15;
pub const FRAME_DEATH102: i32 = 16;
pub const FRAME_DEATH103: i32 = 17;
pub const FRAME_DEATH104: i32 = 18;
pub const FRAME_DEATH105: i32 = 19;
pub const FRAME_DEATH106: i32 = 20;
pub const FRAME_DEATH107: i32 = 21;
pub const FRAME_DEATH108: i32 = 22;
pub const FRAME_DEATH109: i32 = 23;
pub const FRAME_DEATH201: i32 = 24;
pub const FRAME_DEATH202: i32 = 25;
pub const FRAME_DEATH203: i32 = 26;
pub const FRAME_DEATH204: i32 = 27;
pub const FRAME_DEATH205: i32 = 28;
pub const FRAME_DEATH206: i32 = 29;
pub const FRAME_DEATH207: i32 = 30;
pub const FRAME_DEATH208: i32 = 31;
pub const FRAME_DEATH209: i32 = 32;
pub const FRAME_DEATH210: i32 = 33;
pub const FRAME_PAIN101: i32 = 34;
pub const FRAME_PAIN102: i32 = 35;
pub const FRAME_PAIN103: i32 = 36;
pub const FRAME_PAIN104: i32 = 37;
pub const FRAME_PAIN105: i32 = 38;
pub const FRAME_PAIN201: i32 = 39;
pub const FRAME_PAIN202: i32 = 40;
pub const FRAME_PAIN203: i32 = 41;
pub const FRAME_PAIN204: i32 = 42;
pub const FRAME_PAIN205: i32 = 43;
pub const FRAME_PAIN206: i32 = 44;
pub const FRAME_PAIN301: i32 = 45;
pub const FRAME_PAIN302: i32 = 46;
pub const FRAME_PAIN303: i32 = 47;
pub const FRAME_PAIN304: i32 = 48;
pub const FRAME_PAIN305: i32 = 49;
pub const FRAME_PAIN306: i32 = 50;
pub const FRAME_PAIN307: i32 = 51;
pub const FRAME_PAIN308: i32 = 52;
pub const FRAME_PAIN309: i32 = 53;
pub const FRAME_PAIN310: i32 = 54;
pub const FRAME_PAIN311: i32 = 55;
pub const FRAME_RUN03: i32 = 56;
pub const FRAME_RUN04: i32 = 57;
pub const FRAME_RUN05: i32 = 58;
pub const FRAME_RUN06: i32 = 59;
pub const FRAME_RUN07: i32 = 60;
pub const FRAME_RUN08: i32 = 61;
pub const FRAME_STAND101: i32 = 62;
pub const FRAME_STAND102: i32 = 63;
pub const FRAME_STAND103: i32 = 64;
pub const FRAME_STAND104: i32 = 65;
pub const FRAME_STAND105: i32 = 66;
pub const FRAME_STAND106: i32 = 67;
pub const FRAME_STAND107: i32 = 68;
pub const FRAME_STAND108: i32 = 69;
pub const FRAME_STAND109: i32 = 70;
pub const FRAME_STAND110: i32 = 71;
pub const FRAME_STAND111: i32 = 72;
pub const FRAME_STAND112: i32 = 73;
pub const FRAME_STAND113: i32 = 74;
pub const FRAME_STAND114: i32 = 75;
pub const FRAME_STAND115: i32 = 76;
pub const FRAME_STAND116: i32 = 77;
pub const FRAME_STAND117: i32 = 78;
pub const FRAME_STAND118: i32 = 79;
pub const FRAME_STAND119: i32 = 80;
pub const FRAME_STAND120: i32 = 81;
pub const FRAME_STAND121: i32 = 82;
pub const FRAME_STAND122: i32 = 83;
pub const FRAME_STAND123: i32 = 84;
pub const FRAME_STAND124: i32 = 85;
pub const FRAME_STAND125: i32 = 86;
pub const FRAME_STAND126: i32 = 87;
pub const FRAME_STAND127: i32 = 88;
pub const FRAME_STAND128: i32 = 89;
pub const FRAME_STAND129: i32 = 90;
pub const FRAME_STAND130: i32 = 91;
pub const FRAME_STAND131: i32 = 92;
pub const FRAME_STAND132: i32 = 93;
pub const FRAME_STAND133: i32 = 94;
pub const FRAME_STAND134: i32 = 95;
pub const FRAME_STAND135: i32 = 96;
pub const FRAME_STAND136: i32 = 97;
pub const FRAME_STAND137: i32 = 98;
pub const FRAME_STAND138: i32 = 99;
pub const FRAME_STAND139: i32 = 100;
pub const FRAME_STAND140: i32 = 101;
pub const FRAME_STAND141: i32 = 102;
pub const FRAME_STAND142: i32 = 103;
pub const FRAME_STAND143: i32 = 104;
pub const FRAME_STAND144: i32 = 105;
pub const FRAME_STAND145: i32 = 106;
pub const FRAME_STAND146: i32 = 107;
pub const FRAME_STAND147: i32 = 108;
pub const FRAME_STAND148: i32 = 109;
pub const FRAME_STAND149: i32 = 110;
pub const FRAME_STAND150: i32 = 111;
pub const FRAME_STAND151: i32 = 112;
pub const FRAME_STAND152: i32 = 113;
pub const FRAME_STAND153: i32 = 114;
pub const FRAME_STAND154: i32 = 115;
pub const FRAME_STAND155: i32 = 116;
pub const FRAME_STAND156: i32 = 117;
pub const FRAME_STAND157: i32 = 118;
pub const FRAME_STAND158: i32 = 119;
pub const FRAME_STAND159: i32 = 120;
pub const FRAME_STAND160: i32 = 121;
pub const FRAME_STAND161: i32 = 122;
pub const FRAME_STAND162: i32 = 123;
pub const FRAME_STAND163: i32 = 124;
pub const FRAME_STAND164: i32 = 125;
pub const FRAME_WALK01: i32 = 126;
pub const FRAME_WALK02: i32 = 127;
pub const FRAME_WALK03: i32 = 128;
pub const FRAME_WALK04: i32 = 129;
pub const FRAME_WALK05: i32 = 130;
pub const FRAME_WALK06: i32 = 131;
pub const FRAME_WALK07: i32 = 132;
pub const FRAME_WALK08: i32 = 133;
pub const FRAME_WALK09: i32 = 134;
pub const FRAME_WALK10: i32 = 135;
pub const FRAME_WALK11: i32 = 136;
pub const FRAME_WALK12: i32 = 137;
pub const FRAME_WALK13: i32 = 138;
pub const FRAME_WALK14: i32 = 139;
pub const FRAME_WALK15: i32 = 140;
pub const FRAME_WALK16: i32 = 141;
pub const FRAME_WALK17: i32 = 142;
pub const FRAME_WALK18: i32 = 143;
pub const FRAME_WALK19: i32 = 144;
pub const FRAME_WALK20: i32 = 145;
pub const FRAME_WALK21: i32 = 146;
pub const FRAME_WALK22: i32 = 147;
pub const FRAME_WALK23: i32 = 148;

pub const MODEL_SCALE: f32 = 1.0;

// ============================================================
// Sound channel / attenuation constants (mirrors C defines)
// ============================================================

// CHAN_*, ATTN_* come from g_local::* re-export (myq2_common::q_shared)

use crate::ai_wrappers::{ai_stand, ai_walk, ai_run, ai_charge, ai_move};
use crate::entity_adapters::{
    fire_hit, gi_sound, gi_soundindex, gi_modelindex, gi_linkentity,
    g_free_edict, walkmonster_start, throw_gib, throw_head,
};

// ============================================================
// Sound indices (module-level state, replaces C statics)
// ============================================================

#[derive(Default)]
pub struct MutantSounds {
    pub swing: i32,
    pub hit: i32,
    pub hit2: i32,
    pub death: i32,
    pub idle: i32,
    pub pain1: i32,
    pub pain2: i32,
    pub sight: i32,
    pub search: i32,
    pub step1: i32,
    pub step2: i32,
    pub step3: i32,
    pub thud: i32,
}

static SOUNDS: std::sync::OnceLock<MutantSounds> = std::sync::OnceLock::new();

// ============================================================
// Local helpers (not available in entity_adapters)
// ============================================================

fn m_check_bottom(self_ent: &Edict) -> bool {
    let self_idx = self_ent.s.number as i32;
    let mut result = true;
    crate::g_local::with_global_game_ctx(|ctx| {
        result = crate::m_move::m_check_bottom_raw(self_idx, &mut ctx.edicts);
    });
    result
}

fn m_fly_check(self_ent: &mut Edict) {
    let self_idx = self_ent.s.number as i32;
    crate::g_local::with_global_game_ctx(|ctx| {
        crate::g_monster::m_fly_check(ctx, self_idx);
    });
}

/// Helper: resolve an entity index to &Edict and call g_ai::range.
/// Returns RANGE_FAR if the index is invalid.
fn range_by_index(self_ent: &Edict, other_idx: i32) -> i32 {
    if other_idx <= 0 {
        return RANGE_FAR;
    }
    crate::g_local::with_global_game_ctx(|ctx| {
        let oi = other_idx as usize;
        if oi < ctx.edicts.len() {
            crate::g_ai::range(self_ent, &ctx.edicts[oi])
        } else {
            RANGE_FAR
        }
    }).unwrap_or(RANGE_FAR)
}

use myq2_common::q_shared::angle_vectors;





// ============================================================
// Move index constants
// ============================================================

pub const MOVE_STAND: usize = 0;
pub const MOVE_IDLE: usize = 1;
pub const MOVE_WALK: usize = 2;
pub const MOVE_START_WALK: usize = 3;
pub const MOVE_RUN: usize = 4;
pub const MOVE_ATTACK: usize = 5;
pub const MOVE_JUMP: usize = 6;
pub const MOVE_PAIN1: usize = 7;
pub const MOVE_PAIN2: usize = 8;
pub const MOVE_PAIN3: usize = 9;
pub const MOVE_DEATH1: usize = 10;
pub const MOVE_DEATH2: usize = 11;

// ============================================================
// SOUNDS
// ============================================================

pub fn mutant_step(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let n = (rand_i32() + 1) % 3;
    if n == 0 {
        let snd = SOUNDS.get().map_or(0, |s| s.step1);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
    } else if n == 1 {
        let snd = SOUNDS.get().map_or(0, |s| s.step2);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
    } else {
        let snd = SOUNDS.get().map_or(0, |s| s.step3);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
    }
}

pub fn mutant_sight(self_ent: &mut Edict, _other: &mut Edict) {
    let snd = SOUNDS.get().map_or(0, |s| s.sight);
    gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
}

pub fn mutant_search(self_ent: &mut Edict) {
    let snd = SOUNDS.get().map_or(0, |s| s.search);
    gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
}

pub fn mutant_swing(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let snd = SOUNDS.get().map_or(0, |s| s.swing);
    gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
}

// ============================================================
// STAND
// ============================================================

static MUTANT_FRAMES_STAND: [MFrame; 51] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None }, // 10
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None }, // 20
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None }, // 30
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None }, // 40
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None }, // 50
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static MUTANT_MOVE_STAND: MMove = MMove {
    firstframe: FRAME_STAND101,
    lastframe: FRAME_STAND151,
    frames: &MUTANT_FRAMES_STAND,
    endfunc: None,
};

pub fn mutant_stand(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
}

// ============================================================
// IDLE
// ============================================================

fn mutant_idle_loop(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if random() < 0.75 {
        self_ent.monsterinfo.nextframe = FRAME_STAND155;
    }
}

static MUTANT_FRAMES_IDLE: [MFrame; 13] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },                    // scratch loop start
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(mutant_idle_loop) },   // scratch loop end
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static MUTANT_MOVE_IDLE: MMove = MMove {
    firstframe: FRAME_STAND152,
    lastframe: FRAME_STAND164,
    frames: &MUTANT_FRAMES_IDLE,
    endfunc: Some(mutant_stand),
};

pub fn mutant_idle(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_IDLE);
    let snd = SOUNDS.get().map_or(0, |s| s.idle);
    gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_IDLE, 0.0);
}

// ============================================================
// WALK
// ============================================================

static MUTANT_FRAMES_WALK: [MFrame; 12] = [
    MFrame { ai_fn: ai_walk, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 13.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 16.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 15.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.0, think_fn: None },
];

pub static MUTANT_MOVE_WALK: MMove = MMove {
    firstframe: FRAME_WALK05,
    lastframe: FRAME_WALK16,
    frames: &MUTANT_FRAMES_WALK,
    endfunc: None,
};

fn mutant_walk_loop(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_WALK);
}

static MUTANT_FRAMES_START_WALK: [MFrame; 4] = [
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 1.0, think_fn: None },
];

pub static MUTANT_MOVE_START_WALK: MMove = MMove {
    firstframe: FRAME_WALK01,
    lastframe: FRAME_WALK04,
    frames: &MUTANT_FRAMES_START_WALK,
    endfunc: Some(mutant_walk_loop),
};

pub fn mutant_walk(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_START_WALK);
}

// ============================================================
// RUN
// ============================================================

static MUTANT_FRAMES_RUN: [MFrame; 6] = [
    MFrame { ai_fn: ai_run, dist: 40.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 40.0, think_fn: Some(mutant_step) },
    MFrame { ai_fn: ai_run, dist: 24.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 5.0, think_fn: Some(mutant_step) },
    MFrame { ai_fn: ai_run, dist: 17.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 10.0, think_fn: None },
];

pub static MUTANT_MOVE_RUN: MMove = MMove {
    firstframe: FRAME_RUN03,
    lastframe: FRAME_RUN08,
    frames: &MUTANT_FRAMES_RUN,
    endfunc: None,
};

pub fn mutant_run(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_RUN);
    }
}

// ============================================================
// MELEE
// ============================================================

fn mutant_hit_left(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let aim: [f32; 3] = [MELEE_DISTANCE, self_ent.mins[0], 8.0];
    if fire_hit(self_ent, &aim, 10 + (rand_i32() % 5), 100) {
        let snd = SOUNDS.get().map_or(0, |s| s.hit);
        gi_sound(self_ent, CHAN_WEAPON, snd, 1.0, ATTN_NORM, 0.0);
    } else {
        let snd = SOUNDS.get().map_or(0, |s| s.swing);
        gi_sound(self_ent, CHAN_WEAPON, snd, 1.0, ATTN_NORM, 0.0);
    }
}

fn mutant_hit_right(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let aim: [f32; 3] = [MELEE_DISTANCE, self_ent.maxs[0], 8.0];
    if fire_hit(self_ent, &aim, 10 + (rand_i32() % 5), 100) {
        let snd = SOUNDS.get().map_or(0, |s| s.hit2);
        gi_sound(self_ent, CHAN_WEAPON, snd, 1.0, ATTN_NORM, 0.0);
    } else {
        let snd = SOUNDS.get().map_or(0, |s| s.swing);
        gi_sound(self_ent, CHAN_WEAPON, snd, 1.0, ATTN_NORM, 0.0);
    }
}

fn mutant_check_refire(self_ent: &mut Edict, _ctx: &mut GameContext) {
    // if (!self->enemy || !self->enemy->inuse || self->enemy->health <= 0)
    //     return;
    let enemy_idx = self_ent.enemy;
    if enemy_idx < 0 {
        return;
    }
    // Check enemy validity via global context
    {
        let ei = enemy_idx as usize;
        let mut enemy_valid = false;
        crate::g_local::with_global_game_ctx(|ctx| {
            if ei < ctx.edicts.len() && ctx.edicts[ei].inuse && ctx.edicts[ei].health > 0 {
                enemy_valid = true;
            }
        });
        if !enemy_valid {
            return;
        }
    }
    let skill_value: f32 = crate::game_import::gi_cvar("skill", "1", 0);
    if (skill_value == 3.0 && random() < 0.5) || range_by_index(self_ent, enemy_idx) == RANGE_MELEE {
        self_ent.monsterinfo.nextframe = FRAME_ATTACK09;
    }
}

static MUTANT_FRAMES_ATTACK: [MFrame; 7] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(mutant_hit_left) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(mutant_hit_right) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(mutant_check_refire) },
];

pub static MUTANT_MOVE_ATTACK: MMove = MMove {
    firstframe: FRAME_ATTACK09,
    lastframe: FRAME_ATTACK15,
    frames: &MUTANT_FRAMES_ATTACK,
    endfunc: Some(mutant_run),
};

pub fn mutant_melee(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK);
}

// ============================================================
// ATTACK (jump)
// ============================================================

pub fn mutant_jump_touch(self_ent: &mut Edict, other_idx: i32, _plane: Option<&CPlane>, _surf: Option<&CSurface>) {
    if self_ent.health <= 0 {
        self_ent.touch_fn = None;
        return;
    }

    // Check if other takes damage, and apply damage if so
    let self_idx = self_ent.s.number as usize;
    if vector_length(&self_ent.velocity) > 400.0 {
        let mut other_takedamage = false;
        if other_idx > 0 {
            crate::g_local::with_global_game_ctx(|ctx| {
                let oi = other_idx as usize;
                if oi < ctx.edicts.len() {
                    other_takedamage = ctx.edicts[oi].takedamage != 0;
                }
            });
        }
        if other_takedamage {
            let mut normal = self_ent.velocity;
            vector_normalize(&mut normal);
            let point = [
                self_ent.s.origin[0] + self_ent.maxs[0] * normal[0],
                self_ent.s.origin[1] + self_ent.maxs[0] * normal[1],
                self_ent.s.origin[2] + self_ent.maxs[0] * normal[2],
            ];
            let damage = 40 + (10.0 * random()) as i32;
            let velocity = self_ent.velocity;
            crate::g_local::with_global_game_ctx(|ctx| {
                crate::g_combat::ctx_t_damage(
                    ctx, other_idx as usize, self_idx, self_idx,
                    &velocity, &point, &normal, damage, damage, DamageFlags::empty(), MOD_UNKNOWN,
                );
            });
        }
    }

    if !m_check_bottom(self_ent) {
        if self_ent.groundentity >= 0 {
            self_ent.monsterinfo.nextframe = FRAME_ATTACK02;
            self_ent.touch_fn = None;
        }
        return;
    }

    self_ent.touch_fn = None;
}

fn mutant_jump_takeoff(self_ent: &mut Edict, ctx: &mut GameContext) {
    let snd = SOUNDS.get().map_or(0, |s| s.sight);
    gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);

    let mut forward = [0.0_f32; 3];
    angle_vectors(&self_ent.s.angles, Some(&mut forward), None, None);
    self_ent.s.origin[2] += 1.0;
    self_ent.velocity = [
        forward[0] * 600.0,
        forward[1] * 600.0,
        250.0,
    ];
    self_ent.groundentity = -1; // NULL equivalent
    self_ent.monsterinfo.aiflags |= AI_DUCKED;
    self_ent.monsterinfo.attack_finished = ctx.level.time + 3.0;
    self_ent.touch_fn = Some(crate::dispatch::TOUCH_MUTANT_JUMP);
}

fn mutant_check_landing(self_ent: &mut Edict, ctx: &mut GameContext) {
    if self_ent.groundentity >= 0 {
        let snd = SOUNDS.get().map_or(0, |s| s.thud);
        gi_sound(self_ent, CHAN_WEAPON, snd, 1.0, ATTN_NORM, 0.0);
        self_ent.monsterinfo.attack_finished = 0.0;
        self_ent.monsterinfo.aiflags &= !AI_DUCKED;
        return;
    }

    if ctx.level.time > self_ent.monsterinfo.attack_finished {
        self_ent.monsterinfo.nextframe = FRAME_ATTACK02;
    } else {
        self_ent.monsterinfo.nextframe = FRAME_ATTACK05;
    }
}

static MUTANT_FRAMES_JUMP: [MFrame; 8] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 17.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 15.0, think_fn: Some(mutant_jump_takeoff) },
    MFrame { ai_fn: ai_charge, dist: 15.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 15.0, think_fn: Some(mutant_check_landing) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
];

pub static MUTANT_MOVE_JUMP: MMove = MMove {
    firstframe: FRAME_ATTACK01,
    lastframe: FRAME_ATTACK08,
    frames: &MUTANT_FRAMES_JUMP,
    endfunc: Some(mutant_run),
};

pub fn mutant_jump(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_JUMP);
}

// ============================================================
// CHECKATTACK
// ============================================================

pub fn mutant_check_melee(self_ent: &Edict) -> bool {
    range_by_index(self_ent, self_ent.enemy) == RANGE_MELEE
}

pub fn mutant_check_jump(self_ent: &Edict) -> bool {
    let enemy_idx = self_ent.enemy;
    if enemy_idx < 0 {
        return false;
    }

    // Look up enemy entity fields via global context
    let mut enemy_absmin = [0.0_f32; 3];
    let mut _enemy_absmax = [0.0_f32; 3];
    let mut enemy_size = [0.0_f32; 3];
    let mut enemy_origin = [0.0_f32; 3];
    {
        let ei = enemy_idx as usize;
        crate::g_local::with_global_game_ctx(|ctx| {
            if ei < ctx.edicts.len() {
                enemy_absmin = ctx.edicts[ei].absmin;
                _enemy_absmax = ctx.edicts[ei].absmax;
                enemy_size = ctx.edicts[ei].size;
                enemy_origin = ctx.edicts[ei].s.origin;
            }
        });
    }

    if self_ent.absmin[2] > (enemy_absmin[2] + 0.75 * enemy_size[2]) {
        return false;
    }
    if self_ent.absmax[2] < (enemy_absmin[2] + 0.25 * enemy_size[2]) {
        return false;
    }

    let v = [
        self_ent.s.origin[0] - enemy_origin[0],
        self_ent.s.origin[1] - enemy_origin[1],
        0.0,
    ];
    let distance = vector_length(&v);

    if distance < 100.0 {
        return false;
    }
    if distance > 100.0
        && random() < 0.9 {
            return false;
        }

    true
}

pub fn mutant_checkattack(self_ent: &mut Edict, _ctx: &mut GameContext) -> bool {
    let enemy_idx = self_ent.enemy;
    if enemy_idx < 0 {
        return false;
    }
    // Check enemy health via global context
    {
        let ei = enemy_idx as usize;
        let mut enemy_dead = true;
        crate::g_local::with_global_game_ctx(|ctx| {
            if ei < ctx.edicts.len() && ctx.edicts[ei].health > 0 {
                enemy_dead = false;
            }
        });
        if enemy_dead {
            return false;
        }
    }

    if mutant_check_melee(self_ent) {
        self_ent.monsterinfo.attack_state = AS_MELEE;
        return true;
    }

    if mutant_check_jump(self_ent) {
        self_ent.monsterinfo.attack_state = AS_MISSILE;
        // Jump sound not implemented in original Q2
        return true;
    }

    false
}

// ============================================================
// PAIN
// ============================================================

static MUTANT_FRAMES_PAIN1: [MFrame; 5] = [
    MFrame { ai_fn: ai_move, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -8.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 5.0, think_fn: None },
];

pub static MUTANT_MOVE_PAIN1: MMove = MMove {
    firstframe: FRAME_PAIN101,
    lastframe: FRAME_PAIN105,
    frames: &MUTANT_FRAMES_PAIN1,
    endfunc: Some(mutant_run),
};

static MUTANT_FRAMES_PAIN2: [MFrame; 6] = [
    MFrame { ai_fn: ai_move, dist: -24.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 11.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 4.0, think_fn: None },
];

pub static MUTANT_MOVE_PAIN2: MMove = MMove {
    firstframe: FRAME_PAIN201,
    lastframe: FRAME_PAIN206,
    frames: &MUTANT_FRAMES_PAIN2,
    endfunc: Some(mutant_run),
};

static MUTANT_FRAMES_PAIN3: [MFrame; 11] = [
    MFrame { ai_fn: ai_move, dist: -22.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0, think_fn: None },
];

pub static MUTANT_MOVE_PAIN3: MMove = MMove {
    firstframe: FRAME_PAIN301,
    lastframe: FRAME_PAIN311,
    frames: &MUTANT_FRAMES_PAIN3,
    endfunc: Some(mutant_run),
};

pub fn mutant_pain(self_ent: &mut Edict, _other: &mut Edict, _kick: f32, _damage: i32, ctx: &mut GameContext) {
    if self_ent.health < (self_ent.max_health / 2) {
        self_ent.s.skinnum = 1;
    }

    if ctx.level.time < self_ent.pain_debounce_time {
        return;
    }

    self_ent.pain_debounce_time = ctx.level.time + 3.0;

    // skill->value == 3 means nightmare: no pain anims
    let skill_value: f32 = crate::game_import::gi_cvar("skill", "1", 0);
    if skill_value == 3.0 {
        return; // no pain anims in nightmare
    }

    let r = random();
    if r < 0.33 {
        let snd = SOUNDS.get().map_or(0, |s| s.pain1);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN1);
    } else if r < 0.66 {
        let snd = SOUNDS.get().map_or(0, |s| s.pain2);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN2);
    } else {
        let snd = SOUNDS.get().map_or(0, |s| s.pain1);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN3);
    }
}

// ============================================================
// DEATH
// ============================================================

fn mutant_dead(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.mins = [-16.0, -16.0, -24.0];
    self_ent.maxs = [16.0, 16.0, -8.0];
    self_ent.movetype = MoveType::Toss;
    self_ent.svflags |= SVF_DEADMONSTER;
    gi_linkentity(self_ent);

    m_fly_check(self_ent);
}

static MUTANT_FRAMES_DEATH1: [MFrame; 9] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static MUTANT_MOVE_DEATH1: MMove = MMove {
    firstframe: FRAME_DEATH101,
    lastframe: FRAME_DEATH109,
    frames: &MUTANT_FRAMES_DEATH1,
    endfunc: Some(mutant_dead),
};

static MUTANT_FRAMES_DEATH2: [MFrame; 10] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static MUTANT_MOVE_DEATH2: MMove = MMove {
    firstframe: FRAME_DEATH201,
    lastframe: FRAME_DEATH210,
    frames: &MUTANT_FRAMES_DEATH2,
    endfunc: Some(mutant_dead),
};

pub fn mutant_die(self_ent: &mut Edict, _inflictor: &mut Edict, _attacker: &mut Edict, damage: i32, _point: [f32; 3], _ctx: &mut GameContext) {
    if self_ent.health <= self_ent.gib_health {
        gi_sound(self_ent, CHAN_VOICE, gi_soundindex("misc/udeath.wav"), 1.0, ATTN_NORM, 0.0);
        for _ in 0..2 {
            throw_gib(self_ent, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
        }
        for _ in 0..4 {
            throw_gib(self_ent, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
        }
        throw_head(self_ent, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
        self_ent.deadflag = DEAD_DEAD;
        return;
    }

    if self_ent.deadflag == DEAD_DEAD {
        return;
    }

    let snd = SOUNDS.get().map_or(0, |s| s.death);
    gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
    self_ent.deadflag = DEAD_DEAD;
    self_ent.takedamage = Damage::Yes as i32;
    self_ent.s.skinnum = 1;

    if random() < 0.5 {
        self_ent.monsterinfo.currentmove = Some(MOVE_DEATH1);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_DEATH2);
    }
}

// ============================================================
// SPAWN
// ============================================================

/// QUAKED monster_mutant (1 .5 0) (-32 -32 -24) (32 32 32) Ambush Trigger_Spawn Sight
pub fn sp_monster_mutant(self_ent: &mut Edict, ctx: &mut GameContext) {
    if ctx.deathmatch != 0.0 {
        g_free_edict(self_ent);
        return;
    }

    // Pre-caches
    SOUNDS.get_or_init(|| MutantSounds {
        swing: gi_soundindex("mutant/mutatck1.wav"),
        hit: gi_soundindex("mutant/mutatck2.wav"),
        hit2: gi_soundindex("mutant/mutatck3.wav"),
        death: gi_soundindex("mutant/mutdeth1.wav"),
        idle: gi_soundindex("mutant/mutidle1.wav"),
        pain1: gi_soundindex("mutant/mutpain1.wav"),
        pain2: gi_soundindex("mutant/mutpain2.wav"),
        sight: gi_soundindex("mutant/mutsght1.wav"),
        search: gi_soundindex("mutant/mutsrch1.wav"),
        step1: gi_soundindex("mutant/step1.wav"),
        step2: gi_soundindex("mutant/step2.wav"),
        step3: gi_soundindex("mutant/step3.wav"),
        thud: gi_soundindex("mutant/thud1.wav"),
    });

    self_ent.movetype = MoveType::Step;
    self_ent.solid = Solid::Bbox;
    self_ent.s.modelindex = gi_modelindex("models/monsters/mutant/tris.md2");
    self_ent.mins = [-32.0, -32.0, -24.0];
    self_ent.maxs = [32.0, 32.0, 48.0];

    self_ent.health = 300;
    self_ent.gib_health = -120;
    self_ent.mass = 300;

    self_ent.pain_fn = Some(crate::dispatch::PAIN_MUTANT);
    self_ent.die_fn = Some(crate::dispatch::DIE_MUTANT);

    self_ent.monsterinfo.stand_fn = Some(crate::dispatch::MSTAND_MUTANT);
    self_ent.monsterinfo.walk_fn = Some(crate::dispatch::MWALK_MUTANT);
    self_ent.monsterinfo.run_fn = Some(crate::dispatch::MRUN_MUTANT);
    self_ent.monsterinfo.dodge_fn = None;
    self_ent.monsterinfo.attack_fn = None;      // mutant_jump not yet wired as MATTACK
    self_ent.monsterinfo.melee_fn = Some(crate::dispatch::MMELEE_MUTANT);
    self_ent.monsterinfo.sight_fn = Some(crate::dispatch::MSIGHT_MUTANT);
    self_ent.monsterinfo.search_fn = None;      // mutant_search not in dispatch tables
    self_ent.monsterinfo.idle_fn = Some(crate::dispatch::MIDLE_MUTANT);
    self_ent.monsterinfo.checkattack_fn = Some(crate::dispatch::MCHECKATTACK_MUTANT);

    gi_linkentity(self_ent);

    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    self_ent.monsterinfo.scale = MODEL_SCALE;

    walkmonster_start(self_ent);
}

// ============================================================
// Move table: maps move indices to MMove statics
// ============================================================

/// Returns the MMove for a given mutant move index.
pub fn mutant_get_move(index: usize) -> Option<&'static MMove> {
    match index {
        MOVE_STAND => Some(&MUTANT_MOVE_STAND),
        MOVE_IDLE => Some(&MUTANT_MOVE_IDLE),
        MOVE_WALK => Some(&MUTANT_MOVE_WALK),
        MOVE_START_WALK => Some(&MUTANT_MOVE_START_WALK),
        MOVE_RUN => Some(&MUTANT_MOVE_RUN),
        MOVE_ATTACK => Some(&MUTANT_MOVE_ATTACK),
        MOVE_JUMP => Some(&MUTANT_MOVE_JUMP),
        MOVE_PAIN1 => Some(&MUTANT_MOVE_PAIN1),
        MOVE_PAIN2 => Some(&MUTANT_MOVE_PAIN2),
        MOVE_PAIN3 => Some(&MUTANT_MOVE_PAIN3),
        MOVE_DEATH1 => Some(&MUTANT_MOVE_DEATH1),
        MOVE_DEATH2 => Some(&MUTANT_MOVE_DEATH2),
        _ => None,
    }
}
