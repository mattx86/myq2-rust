// m_tank.rs â€” Tank monster
// Converted from: myq2-original/game/m_tank.c
// Frame definitions from: myq2-original/game/m_tank.h

use crate::g_local::*;
use crate::game::*;
use crate::m_flash::MONSTER_FLASH_OFFSET;
use crate::entity_adapters::{
    gi_sound, gi_soundindex, gi_modelindex, gi_linkentity,
    g_free_edict, walkmonster_start, throw_gib, throw_head,
    g_project_source, monster_fire_blaster, monster_fire_rocket,
    monster_fire_bullet,
};
use myq2_common::common::frand as random;
use myq2_common::q_shared::{vector_normalize, vector_length};

// ============================================================
// Frame definitions (from m_tank.h)
// This file generated by qdata - Do NOT Modify
// ============================================================

pub const FRAME_STAND01: i32 = 0;
pub const FRAME_STAND02: i32 = 1;
pub const FRAME_STAND03: i32 = 2;
pub const FRAME_STAND04: i32 = 3;
pub const FRAME_STAND05: i32 = 4;
pub const FRAME_STAND06: i32 = 5;
pub const FRAME_STAND07: i32 = 6;
pub const FRAME_STAND08: i32 = 7;
pub const FRAME_STAND09: i32 = 8;
pub const FRAME_STAND10: i32 = 9;
pub const FRAME_STAND11: i32 = 10;
pub const FRAME_STAND12: i32 = 11;
pub const FRAME_STAND13: i32 = 12;
pub const FRAME_STAND14: i32 = 13;
pub const FRAME_STAND15: i32 = 14;
pub const FRAME_STAND16: i32 = 15;
pub const FRAME_STAND17: i32 = 16;
pub const FRAME_STAND18: i32 = 17;
pub const FRAME_STAND19: i32 = 18;
pub const FRAME_STAND20: i32 = 19;
pub const FRAME_STAND21: i32 = 20;
pub const FRAME_STAND22: i32 = 21;
pub const FRAME_STAND23: i32 = 22;
pub const FRAME_STAND24: i32 = 23;
pub const FRAME_STAND25: i32 = 24;
pub const FRAME_STAND26: i32 = 25;
pub const FRAME_STAND27: i32 = 26;
pub const FRAME_STAND28: i32 = 27;
pub const FRAME_STAND29: i32 = 28;
pub const FRAME_STAND30: i32 = 29;
pub const FRAME_WALK01: i32 = 30;
pub const FRAME_WALK02: i32 = 31;
pub const FRAME_WALK03: i32 = 32;
pub const FRAME_WALK04: i32 = 33;
pub const FRAME_WALK05: i32 = 34;
pub const FRAME_WALK06: i32 = 35;
pub const FRAME_WALK07: i32 = 36;
pub const FRAME_WALK08: i32 = 37;
pub const FRAME_WALK09: i32 = 38;
pub const FRAME_WALK10: i32 = 39;
pub const FRAME_WALK11: i32 = 40;
pub const FRAME_WALK12: i32 = 41;
pub const FRAME_WALK13: i32 = 42;
pub const FRAME_WALK14: i32 = 43;
pub const FRAME_WALK15: i32 = 44;
pub const FRAME_WALK16: i32 = 45;
pub const FRAME_WALK17: i32 = 46;
pub const FRAME_WALK18: i32 = 47;
pub const FRAME_WALK19: i32 = 48;
pub const FRAME_WALK20: i32 = 49;
pub const FRAME_WALK21: i32 = 50;
pub const FRAME_WALK22: i32 = 51;
pub const FRAME_WALK23: i32 = 52;
pub const FRAME_WALK24: i32 = 53;
pub const FRAME_WALK25: i32 = 54;
pub const FRAME_ATTAK101: i32 = 55;
pub const FRAME_ATTAK102: i32 = 56;
pub const FRAME_ATTAK103: i32 = 57;
pub const FRAME_ATTAK104: i32 = 58;
pub const FRAME_ATTAK105: i32 = 59;
pub const FRAME_ATTAK106: i32 = 60;
pub const FRAME_ATTAK107: i32 = 61;
pub const FRAME_ATTAK108: i32 = 62;
pub const FRAME_ATTAK109: i32 = 63;
pub const FRAME_ATTAK110: i32 = 64;
pub const FRAME_ATTAK111: i32 = 65;
pub const FRAME_ATTAK112: i32 = 66;
pub const FRAME_ATTAK113: i32 = 67;
pub const FRAME_ATTAK114: i32 = 68;
pub const FRAME_ATTAK115: i32 = 69;
pub const FRAME_ATTAK116: i32 = 70;
pub const FRAME_ATTAK117: i32 = 71;
pub const FRAME_ATTAK118: i32 = 72;
pub const FRAME_ATTAK119: i32 = 73;
pub const FRAME_ATTAK120: i32 = 74;
pub const FRAME_ATTAK121: i32 = 75;
pub const FRAME_ATTAK122: i32 = 76;
pub const FRAME_ATTAK201: i32 = 77;
pub const FRAME_ATTAK202: i32 = 78;
pub const FRAME_ATTAK203: i32 = 79;
pub const FRAME_ATTAK204: i32 = 80;
pub const FRAME_ATTAK205: i32 = 81;
pub const FRAME_ATTAK206: i32 = 82;
pub const FRAME_ATTAK207: i32 = 83;
pub const FRAME_ATTAK208: i32 = 84;
pub const FRAME_ATTAK209: i32 = 85;
pub const FRAME_ATTAK210: i32 = 86;
pub const FRAME_ATTAK211: i32 = 87;
pub const FRAME_ATTAK212: i32 = 88;
pub const FRAME_ATTAK213: i32 = 89;
pub const FRAME_ATTAK214: i32 = 90;
pub const FRAME_ATTAK215: i32 = 91;
pub const FRAME_ATTAK216: i32 = 92;
pub const FRAME_ATTAK217: i32 = 93;
pub const FRAME_ATTAK218: i32 = 94;
pub const FRAME_ATTAK219: i32 = 95;
pub const FRAME_ATTAK220: i32 = 96;
pub const FRAME_ATTAK221: i32 = 97;
pub const FRAME_ATTAK222: i32 = 98;
pub const FRAME_ATTAK223: i32 = 99;
pub const FRAME_ATTAK224: i32 = 100;
pub const FRAME_ATTAK225: i32 = 101;
pub const FRAME_ATTAK226: i32 = 102;
pub const FRAME_ATTAK227: i32 = 103;
pub const FRAME_ATTAK228: i32 = 104;
pub const FRAME_ATTAK229: i32 = 105;
pub const FRAME_ATTAK230: i32 = 106;
pub const FRAME_ATTAK231: i32 = 107;
pub const FRAME_ATTAK232: i32 = 108;
pub const FRAME_ATTAK233: i32 = 109;
pub const FRAME_ATTAK234: i32 = 110;
pub const FRAME_ATTAK235: i32 = 111;
pub const FRAME_ATTAK236: i32 = 112;
pub const FRAME_ATTAK237: i32 = 113;
pub const FRAME_ATTAK238: i32 = 114;
pub const FRAME_ATTAK301: i32 = 115;
pub const FRAME_ATTAK302: i32 = 116;
pub const FRAME_ATTAK303: i32 = 117;
pub const FRAME_ATTAK304: i32 = 118;
pub const FRAME_ATTAK305: i32 = 119;
pub const FRAME_ATTAK306: i32 = 120;
pub const FRAME_ATTAK307: i32 = 121;
pub const FRAME_ATTAK308: i32 = 122;
pub const FRAME_ATTAK309: i32 = 123;
pub const FRAME_ATTAK310: i32 = 124;
pub const FRAME_ATTAK311: i32 = 125;
pub const FRAME_ATTAK312: i32 = 126;
pub const FRAME_ATTAK313: i32 = 127;
pub const FRAME_ATTAK314: i32 = 128;
pub const FRAME_ATTAK315: i32 = 129;
pub const FRAME_ATTAK316: i32 = 130;
pub const FRAME_ATTAK317: i32 = 131;
pub const FRAME_ATTAK318: i32 = 132;
pub const FRAME_ATTAK319: i32 = 133;
pub const FRAME_ATTAK320: i32 = 134;
pub const FRAME_ATTAK321: i32 = 135;
pub const FRAME_ATTAK322: i32 = 136;
pub const FRAME_ATTAK323: i32 = 137;
pub const FRAME_ATTAK324: i32 = 138;
pub const FRAME_ATTAK325: i32 = 139;
pub const FRAME_ATTAK326: i32 = 140;
pub const FRAME_ATTAK327: i32 = 141;
pub const FRAME_ATTAK328: i32 = 142;
pub const FRAME_ATTAK329: i32 = 143;
pub const FRAME_ATTAK330: i32 = 144;
pub const FRAME_ATTAK331: i32 = 145;
pub const FRAME_ATTAK332: i32 = 146;
pub const FRAME_ATTAK333: i32 = 147;
pub const FRAME_ATTAK334: i32 = 148;
pub const FRAME_ATTAK335: i32 = 149;
pub const FRAME_ATTAK336: i32 = 150;
pub const FRAME_ATTAK337: i32 = 151;
pub const FRAME_ATTAK338: i32 = 152;
pub const FRAME_ATTAK339: i32 = 153;
pub const FRAME_ATTAK340: i32 = 154;
pub const FRAME_ATTAK341: i32 = 155;
pub const FRAME_ATTAK342: i32 = 156;
pub const FRAME_ATTAK343: i32 = 157;
pub const FRAME_ATTAK344: i32 = 158;
pub const FRAME_ATTAK345: i32 = 159;
pub const FRAME_ATTAK346: i32 = 160;
pub const FRAME_ATTAK347: i32 = 161;
pub const FRAME_ATTAK348: i32 = 162;
pub const FRAME_ATTAK349: i32 = 163;
pub const FRAME_ATTAK350: i32 = 164;
pub const FRAME_ATTAK351: i32 = 165;
pub const FRAME_ATTAK352: i32 = 166;
pub const FRAME_ATTAK353: i32 = 167;
pub const FRAME_ATTAK401: i32 = 168;
pub const FRAME_ATTAK402: i32 = 169;
pub const FRAME_ATTAK403: i32 = 170;
pub const FRAME_ATTAK404: i32 = 171;
pub const FRAME_ATTAK405: i32 = 172;
pub const FRAME_ATTAK406: i32 = 173;
pub const FRAME_ATTAK407: i32 = 174;
pub const FRAME_ATTAK408: i32 = 175;
pub const FRAME_ATTAK409: i32 = 176;
pub const FRAME_ATTAK410: i32 = 177;
pub const FRAME_ATTAK411: i32 = 178;
pub const FRAME_ATTAK412: i32 = 179;
pub const FRAME_ATTAK413: i32 = 180;
pub const FRAME_ATTAK414: i32 = 181;
pub const FRAME_ATTAK415: i32 = 182;
pub const FRAME_ATTAK416: i32 = 183;
pub const FRAME_ATTAK417: i32 = 184;
pub const FRAME_ATTAK418: i32 = 185;
pub const FRAME_ATTAK419: i32 = 186;
pub const FRAME_ATTAK420: i32 = 187;
pub const FRAME_ATTAK421: i32 = 188;
pub const FRAME_ATTAK422: i32 = 189;
pub const FRAME_ATTAK423: i32 = 190;
pub const FRAME_ATTAK424: i32 = 191;
pub const FRAME_ATTAK425: i32 = 192;
pub const FRAME_ATTAK426: i32 = 193;
pub const FRAME_ATTAK427: i32 = 194;
pub const FRAME_ATTAK428: i32 = 195;
pub const FRAME_ATTAK429: i32 = 196;
pub const FRAME_PAIN101: i32 = 197;
pub const FRAME_PAIN102: i32 = 198;
pub const FRAME_PAIN103: i32 = 199;
pub const FRAME_PAIN104: i32 = 200;
pub const FRAME_PAIN201: i32 = 201;
pub const FRAME_PAIN202: i32 = 202;
pub const FRAME_PAIN203: i32 = 203;
pub const FRAME_PAIN204: i32 = 204;
pub const FRAME_PAIN205: i32 = 205;
pub const FRAME_PAIN301: i32 = 206;
pub const FRAME_PAIN302: i32 = 207;
pub const FRAME_PAIN303: i32 = 208;
pub const FRAME_PAIN304: i32 = 209;
pub const FRAME_PAIN305: i32 = 210;
pub const FRAME_PAIN306: i32 = 211;
pub const FRAME_PAIN307: i32 = 212;
pub const FRAME_PAIN308: i32 = 213;
pub const FRAME_PAIN309: i32 = 214;
pub const FRAME_PAIN310: i32 = 215;
pub const FRAME_PAIN311: i32 = 216;
pub const FRAME_PAIN312: i32 = 217;
pub const FRAME_PAIN313: i32 = 218;
pub const FRAME_PAIN314: i32 = 219;
pub const FRAME_PAIN315: i32 = 220;
pub const FRAME_PAIN316: i32 = 221;
pub const FRAME_DEATH101: i32 = 222;
pub const FRAME_DEATH102: i32 = 223;
pub const FRAME_DEATH103: i32 = 224;
pub const FRAME_DEATH104: i32 = 225;
pub const FRAME_DEATH105: i32 = 226;
pub const FRAME_DEATH106: i32 = 227;
pub const FRAME_DEATH107: i32 = 228;
pub const FRAME_DEATH108: i32 = 229;
pub const FRAME_DEATH109: i32 = 230;
pub const FRAME_DEATH110: i32 = 231;
pub const FRAME_DEATH111: i32 = 232;
pub const FRAME_DEATH112: i32 = 233;
pub const FRAME_DEATH113: i32 = 234;
pub const FRAME_DEATH114: i32 = 235;
pub const FRAME_DEATH115: i32 = 236;
pub const FRAME_DEATH116: i32 = 237;
pub const FRAME_DEATH117: i32 = 238;
pub const FRAME_DEATH118: i32 = 239;
pub const FRAME_DEATH119: i32 = 240;
pub const FRAME_DEATH120: i32 = 241;
pub const FRAME_DEATH121: i32 = 242;
pub const FRAME_DEATH122: i32 = 243;
pub const FRAME_DEATH123: i32 = 244;
pub const FRAME_DEATH124: i32 = 245;
pub const FRAME_DEATH125: i32 = 246;
pub const FRAME_DEATH126: i32 = 247;
pub const FRAME_DEATH127: i32 = 248;
pub const FRAME_DEATH128: i32 = 249;
pub const FRAME_DEATH129: i32 = 250;
pub const FRAME_DEATH130: i32 = 251;
pub const FRAME_DEATH131: i32 = 252;
pub const FRAME_DEATH132: i32 = 253;
pub const FRAME_RECLN101: i32 = 254;
pub const FRAME_RECLN102: i32 = 255;
pub const FRAME_RECLN103: i32 = 256;
pub const FRAME_RECLN104: i32 = 257;
pub const FRAME_RECLN105: i32 = 258;
pub const FRAME_RECLN106: i32 = 259;
pub const FRAME_RECLN107: i32 = 260;
pub const FRAME_RECLN108: i32 = 261;
pub const FRAME_RECLN109: i32 = 262;
pub const FRAME_RECLN110: i32 = 263;
pub const FRAME_RECLN111: i32 = 264;
pub const FRAME_RECLN112: i32 = 265;
pub const FRAME_RECLN113: i32 = 266;
pub const FRAME_RECLN114: i32 = 267;
pub const FRAME_RECLN115: i32 = 268;
pub const FRAME_RECLN116: i32 = 269;
pub const FRAME_RECLN117: i32 = 270;
pub const FRAME_RECLN118: i32 = 271;
pub const FRAME_RECLN119: i32 = 272;
pub const FRAME_RECLN120: i32 = 273;
pub const FRAME_RECLN121: i32 = 274;
pub const FRAME_RECLN122: i32 = 275;
pub const FRAME_RECLN123: i32 = 276;
pub const FRAME_RECLN124: i32 = 277;
pub const FRAME_RECLN125: i32 = 278;
pub const FRAME_RECLN126: i32 = 279;
pub const FRAME_RECLN127: i32 = 280;
pub const FRAME_RECLN128: i32 = 281;
pub const FRAME_RECLN129: i32 = 282;
pub const FRAME_RECLN130: i32 = 283;
pub const FRAME_RECLN131: i32 = 284;
pub const FRAME_RECLN132: i32 = 285;
pub const FRAME_RECLN133: i32 = 286;
pub const FRAME_RECLN134: i32 = 287;
pub const FRAME_RECLN135: i32 = 288;
pub const FRAME_RECLN136: i32 = 289;
pub const FRAME_RECLN137: i32 = 290;
pub const FRAME_RECLN138: i32 = 291;
pub const FRAME_RECLN139: i32 = 292;
pub const FRAME_RECLN140: i32 = 293;

pub const MODEL_SCALE: f32 = 1.0;

// ============================================================
// Sound channel / attenuation constants (mirrors C defines)
// ============================================================

// CHAN_*, ATTN_* come from g_local::* re-export (myq2_common::q_shared)

// ============================================================

use crate::ai_wrappers::{ai_stand, ai_walk, ai_run, ai_charge, ai_move};

// ============================================================
// Sound indices (module-level state, replaces C statics)
// ============================================================

#[derive(Default)]
pub struct TankSounds {
    pub thud: i32,
    pub pain: i32,
    pub idle: i32,
    pub die: i32,
    pub step: i32,
    pub sight: i32,
    pub windup: i32,
    pub strike: i32,
}

static SOUNDS: std::sync::OnceLock<TankSounds> = std::sync::OnceLock::new();

// ============================================================
// Local helpers (signatures differ from entity_adapters)
// ============================================================

/// Delegates to g_ai::visible via the global game context.
fn visible(self_ent: &Edict, other_index: Option<usize>) -> bool {
    if let Some(oi) = other_index {
        crate::g_local::with_global_game_ctx(|ctx| {
            if oi < ctx.edicts.len() && ctx.edicts[oi].inuse {
                crate::g_ai::visible(self_ent, &ctx.edicts[oi])
            } else {
                false
            }
        }).unwrap_or(false)
    } else {
        false
    }
}

use myq2_common::q_shared::angle_vectors;





// ============================================================
// Move table indices (used for monsterinfo.currentmove)
// ============================================================

pub const MOVE_STAND: usize = 0;
pub const MOVE_START_WALK: usize = 1;
pub const MOVE_WALK: usize = 2;
pub const MOVE_STOP_WALK: usize = 3;
pub const MOVE_START_RUN: usize = 4;
pub const MOVE_RUN: usize = 5;
pub const MOVE_STOP_RUN: usize = 6;
pub const MOVE_PAIN1: usize = 7;
pub const MOVE_PAIN2: usize = 8;
pub const MOVE_PAIN3: usize = 9;
pub const MOVE_ATTACK_BLAST: usize = 10;
pub const MOVE_REATTACK_BLAST: usize = 11;
pub const MOVE_ATTACK_POST_BLAST: usize = 12;
pub const MOVE_ATTACK_STRIKE: usize = 13;
pub const MOVE_ATTACK_PRE_ROCKET: usize = 14;
pub const MOVE_ATTACK_FIRE_ROCKET: usize = 15;
pub const MOVE_ATTACK_POST_ROCKET: usize = 16;
pub const MOVE_ATTACK_CHAIN: usize = 17;
pub const MOVE_DEATH: usize = 18;

// ============================================================
// Misc behavior functions
// ============================================================

pub fn tank_sight(self_ent: &mut Edict, _other: &mut Edict) {
    let sound_sight = SOUNDS.get().map_or(0, |s| s.sight);
    gi_sound(self_ent, CHAN_VOICE, sound_sight, 1.0, ATTN_NORM, 0.0);
}

fn tank_footstep(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_step = SOUNDS.get().map_or(0, |s| s.step);
    gi_sound(self_ent, CHAN_BODY, sound_step, 1.0, ATTN_NORM, 0.0);
}

fn tank_thud(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_thud = SOUNDS.get().map_or(0, |s| s.thud);
    gi_sound(self_ent, CHAN_BODY, sound_thud, 1.0, ATTN_NORM, 0.0);
}

fn tank_windup(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_windup = SOUNDS.get().map_or(0, |s| s.windup);
    gi_sound(self_ent, CHAN_WEAPON, sound_windup, 1.0, ATTN_NORM, 0.0);
}

pub fn tank_idle(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_idle = SOUNDS.get().map_or(0, |s| s.idle);
    gi_sound(self_ent, CHAN_VOICE, sound_idle, 1.0, ATTN_IDLE, 0.0);
}

// ============================================================
// Stand animation
// ============================================================

static TANK_FRAMES_STAND: [MFrame; 30] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static TANK_MOVE_STAND: MMove = MMove {
    firstframe: FRAME_STAND01,
    lastframe: FRAME_STAND30,
    frames: &TANK_FRAMES_STAND,
    endfunc: None,
};

pub fn tank_stand(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
}

// ============================================================
// Walk animation
// ============================================================

static TANK_FRAMES_START_WALK: [MFrame; 4] = [
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 11.0, think_fn: Some(tank_footstep) },
];

pub static TANK_MOVE_START_WALK: MMove = MMove {
    firstframe: FRAME_WALK01,
    lastframe: FRAME_WALK04,
    frames: &TANK_FRAMES_START_WALK,
    endfunc: Some(tank_walk),
};

static TANK_FRAMES_WALK: [MFrame; 16] = [
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: Some(tank_footstep) },
    MFrame { ai_fn: ai_walk, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 7.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 7.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.0, think_fn: Some(tank_footstep) },
];

pub static TANK_MOVE_WALK: MMove = MMove {
    firstframe: FRAME_WALK05,
    lastframe: FRAME_WALK20,
    frames: &TANK_FRAMES_WALK,
    endfunc: None,
};

static TANK_FRAMES_STOP_WALK: [MFrame; 5] = [
    MFrame { ai_fn: ai_walk, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: Some(tank_footstep) },
];

pub static TANK_MOVE_STOP_WALK: MMove = MMove {
    firstframe: FRAME_WALK21,
    lastframe: FRAME_WALK25,
    frames: &TANK_FRAMES_STOP_WALK,
    endfunc: Some(tank_stand),
};

pub fn tank_walk(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_WALK);
}

// ============================================================
// Run animation
// ============================================================

static TANK_FRAMES_START_RUN: [MFrame; 4] = [
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 11.0, think_fn: Some(tank_footstep) },
];

pub static TANK_MOVE_START_RUN: MMove = MMove {
    firstframe: FRAME_WALK01,
    lastframe: FRAME_WALK04,
    frames: &TANK_FRAMES_START_RUN,
    endfunc: Some(tank_run),
};

static TANK_FRAMES_RUN: [MFrame; 16] = [
    MFrame { ai_fn: ai_run, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 4.0, think_fn: Some(tank_footstep) },
    MFrame { ai_fn: ai_run, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 7.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 7.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 6.0, think_fn: Some(tank_footstep) },
];

pub static TANK_MOVE_RUN: MMove = MMove {
    firstframe: FRAME_WALK05,
    lastframe: FRAME_WALK20,
    frames: &TANK_FRAMES_RUN,
    endfunc: None,
};

static TANK_FRAMES_STOP_RUN: [MFrame; 5] = [
    MFrame { ai_fn: ai_run, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 4.0, think_fn: Some(tank_footstep) },
];

pub static TANK_MOVE_STOP_RUN: MMove = MMove {
    firstframe: FRAME_WALK21,
    lastframe: FRAME_WALK25,
    frames: &TANK_FRAMES_STOP_RUN,
    endfunc: Some(tank_walk),
};

pub fn tank_run(self_ent: &mut Edict, ctx: &mut GameContext) {
    if self_ent.enemy > 0 {
        let ei = self_ent.enemy as usize;
        let is_client = ei < ctx.edicts.len() && ctx.edicts[ei].client.is_some();
        if is_client {
            self_ent.monsterinfo.aiflags |= AI_BRUTAL;
        }
    } else {
        self_ent.monsterinfo.aiflags &= !AI_BRUTAL;
    }

    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
        return;
    }

    if self_ent.monsterinfo.currentmove == Some(MOVE_WALK)
        || self_ent.monsterinfo.currentmove == Some(MOVE_START_RUN)
    {
        self_ent.monsterinfo.currentmove = Some(MOVE_RUN);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_START_RUN);
    }
}

// ============================================================
// Pain animation
// ============================================================

static TANK_FRAMES_PAIN1: [MFrame; 4] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static TANK_MOVE_PAIN1: MMove = MMove {
    firstframe: FRAME_PAIN101,
    lastframe: FRAME_PAIN104,
    frames: &TANK_FRAMES_PAIN1,
    endfunc: Some(tank_run),
};

static TANK_FRAMES_PAIN2: [MFrame; 5] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static TANK_MOVE_PAIN2: MMove = MMove {
    firstframe: FRAME_PAIN201,
    lastframe: FRAME_PAIN205,
    frames: &TANK_FRAMES_PAIN2,
    endfunc: Some(tank_run),
};

static TANK_FRAMES_PAIN3: [MFrame; 16] = [
    MFrame { ai_fn: ai_move, dist: -7.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(tank_footstep) },
];

pub static TANK_MOVE_PAIN3: MMove = MMove {
    firstframe: FRAME_PAIN301,
    lastframe: FRAME_PAIN316,
    frames: &TANK_FRAMES_PAIN3,
    endfunc: Some(tank_run),
};

pub fn tank_pain(self_ent: &mut Edict, _other: &mut Edict, _kick: f32, damage: i32, ctx: &mut GameContext) {
    if self_ent.health < (self_ent.max_health / 2) {
        self_ent.s.skinnum |= 1;
    }

    if damage <= 10 {
        return;
    }

    if ctx.level.time < self_ent.pain_debounce_time {
        return;
    }

    if damage <= 30
        && random() > 0.2 {
            return;
        }

    // If hard or nightmare, don't go into pain while attacking
    if ctx.skill >= 2.0 {
        if self_ent.s.frame >= FRAME_ATTAK301 && self_ent.s.frame <= FRAME_ATTAK330 {
            return;
        }
        if self_ent.s.frame >= FRAME_ATTAK101 && self_ent.s.frame <= FRAME_ATTAK116 {
            return;
        }
    }

    self_ent.pain_debounce_time = ctx.level.time + 3.0;
    let sound_pain = SOUNDS.get().map_or(0, |s| s.pain);
    gi_sound(self_ent, CHAN_VOICE, sound_pain, 1.0, ATTN_NORM, 0.0);

    if ctx.skill == 3.0 {
        return; // no pain anims in nightmare
    }

    if damage <= 30 {
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN1);
    } else if damage <= 60 {
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN2);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN3);
    }
}

// ============================================================
// Attacks
// ============================================================

fn tank_blaster(self_ent: &mut Edict, ctx: &mut GameContext) {
    let mut forward = [0.0f32; 3];
    let mut right = [0.0f32; 3];
    let mut start = [0.0f32; 3];
    let mut dir = [0.0f32; 3];

    let flash_number = if self_ent.s.frame == FRAME_ATTAK110 {
        MZ2_TANK_BLASTER_1
    } else if self_ent.s.frame == FRAME_ATTAK113 {
        MZ2_TANK_BLASTER_2
    } else {
        MZ2_TANK_BLASTER_3
    };

    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
    g_project_source(&self_ent.s.origin, &MONSTER_FLASH_OFFSET[flash_number as usize], &forward, &right, &mut start);

    // Get enemy origin for aim direction
    let enemy_idx = self_ent.enemy;
    if enemy_idx > 0 && (enemy_idx as usize) < ctx.edicts.len() {
        let ei = enemy_idx as usize;
        let mut end = ctx.edicts[ei].s.origin;
        end[2] += ctx.edicts[ei].viewheight as f32;
        dir = [end[0] - start[0], end[1] - start[1], end[2] - start[2]];
        vector_normalize(&mut dir);
    }

    monster_fire_blaster(self_ent, start, dir, 30, 800, flash_number, EF_BLASTER as i32);
}

fn tank_strike(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_strike = SOUNDS.get().map_or(0, |s| s.strike);
    gi_sound(self_ent, CHAN_WEAPON, sound_strike, 1.0, ATTN_NORM, 0.0);
}

fn tank_rocket(self_ent: &mut Edict, ctx: &mut GameContext) {
    let mut forward = [0.0f32; 3];
    let mut right = [0.0f32; 3];
    let mut start = [0.0f32; 3];
    let mut dir = [0.0f32; 3];

    let flash_number = if self_ent.s.frame == FRAME_ATTAK324 {
        MZ2_TANK_ROCKET_1
    } else if self_ent.s.frame == FRAME_ATTAK327 {
        MZ2_TANK_ROCKET_2
    } else {
        MZ2_TANK_ROCKET_3
    };

    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
    g_project_source(&self_ent.s.origin, &MONSTER_FLASH_OFFSET[flash_number as usize], &forward, &right, &mut start);

    let enemy_idx = self_ent.enemy;
    if enemy_idx > 0 && (enemy_idx as usize) < ctx.edicts.len() {
        let ei = enemy_idx as usize;
        let mut vec = ctx.edicts[ei].s.origin;
        vec[2] += ctx.edicts[ei].viewheight as f32;
        dir = [vec[0] - start[0], vec[1] - start[1], vec[2] - start[2]];
        vector_normalize(&mut dir);
    }

    monster_fire_rocket(self_ent, start, dir, 50, 550, flash_number);
}

fn tank_machinegun(self_ent: &mut Edict, ctx: &mut GameContext) {
    let mut dir = [0.0f32; 3];
    let mut start = [0.0f32; 3];
    let mut forward = [0.0f32; 3];
    let mut right = [0.0f32; 3];

    let flash_number = MZ2_TANK_MACHINEGUN_1 + (self_ent.s.frame - FRAME_ATTAK406);

    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
    g_project_source(&self_ent.s.origin, &MONSTER_FLASH_OFFSET[flash_number as usize], &forward, &right, &mut start);

    let enemy_idx = self_ent.enemy;
    if enemy_idx > 0 && (enemy_idx as usize) < ctx.edicts.len() {
        let ei = enemy_idx as usize;
        let mut vec = ctx.edicts[ei].s.origin;
        vec[2] += ctx.edicts[ei].viewheight as f32;
        vec = [vec[0] - start[0], vec[1] - start[1], vec[2] - start[2]];
        let mut angles = [0.0f32; 3];
        crate::g_utils::vectoangles(&vec, &mut angles);
        dir[0] = angles[0];
    } else {
        dir[0] = 0.0;
    }

    if self_ent.s.frame <= FRAME_ATTAK415 {
        dir[1] = self_ent.s.angles[1] - 8.0 * (self_ent.s.frame - FRAME_ATTAK411) as f32;
    } else {
        dir[1] = self_ent.s.angles[1] + 8.0 * (self_ent.s.frame - FRAME_ATTAK419) as f32;
    }
    dir[2] = 0.0;

    angle_vectors(&dir, Some(&mut forward), None, None);

    monster_fire_bullet(self_ent, start, forward, 20, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
}

// ============================================================
// Attack: blaster animation
// ============================================================

static TANK_FRAMES_ATTACK_BLAST: [MFrame; 16] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(tank_blaster) },    // 10
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(tank_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(tank_blaster) },    // 16
];

pub static TANK_MOVE_ATTACK_BLAST: MMove = MMove {
    firstframe: FRAME_ATTAK101,
    lastframe: FRAME_ATTAK116,
    frames: &TANK_FRAMES_ATTACK_BLAST,
    endfunc: Some(tank_reattack_blaster),
};

static TANK_FRAMES_REATTACK_BLAST: [MFrame; 6] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(tank_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(tank_blaster) },    // 16
];

pub static TANK_MOVE_REATTACK_BLAST: MMove = MMove {
    firstframe: FRAME_ATTAK111,
    lastframe: FRAME_ATTAK116,
    frames: &TANK_FRAMES_REATTACK_BLAST,
    endfunc: Some(tank_reattack_blaster),
};

static TANK_FRAMES_ATTACK_POST_BLAST: [MFrame; 6] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },      // 17
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: Some(tank_footstep) },  // 22
];

pub static TANK_MOVE_ATTACK_POST_BLAST: MMove = MMove {
    firstframe: FRAME_ATTAK117,
    lastframe: FRAME_ATTAK122,
    frames: &TANK_FRAMES_ATTACK_POST_BLAST,
    endfunc: Some(tank_run),
};

fn tank_reattack_blaster(self_ent: &mut Edict, ctx: &mut GameContext) {
    let enemy_opt = if self_ent.enemy >= 0 { Some(self_ent.enemy as usize) } else { None };
    if ctx.skill >= 2.0
        && visible(self_ent, enemy_opt)
            && self_ent.enemy >= 0 {
                let ei = self_ent.enemy as usize;
                let enemy_alive = ei < ctx.edicts.len() && ctx.edicts[ei].health > 0;
                if enemy_alive && random() <= 0.6 {
                    self_ent.monsterinfo.currentmove = Some(MOVE_REATTACK_BLAST);
                    return;
                }
            }
    self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_POST_BLAST);
}

// ============================================================
// Attack: strike (melee) animation
// ============================================================

fn tank_poststrike(self_ent: &mut Edict, ctx: &mut GameContext) {
    self_ent.enemy = 0;
    tank_run(self_ent, ctx);
}

static TANK_FRAMES_ATTACK_STRIKE: [MFrame; 38] = [
    MFrame { ai_fn: ai_move, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 7.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 9.0, think_fn: Some(tank_footstep) },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: Some(tank_footstep) },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(tank_windup) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(tank_strike) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -10.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -10.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: Some(tank_footstep) },
];

pub static TANK_MOVE_ATTACK_STRIKE: MMove = MMove {
    firstframe: FRAME_ATTAK201,
    lastframe: FRAME_ATTAK238,
    frames: &TANK_FRAMES_ATTACK_STRIKE,
    endfunc: Some(tank_poststrike),
};

// ============================================================
// Attack: rocket animation
// ============================================================

static TANK_FRAMES_ATTACK_PRE_ROCKET: [MFrame; 21] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },    // 10
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 7.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 7.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 7.0, think_fn: Some(tank_footstep) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },    // 20
    MFrame { ai_fn: ai_charge, dist: -3.0, think_fn: None },
];

pub static TANK_MOVE_ATTACK_PRE_ROCKET: MMove = MMove {
    firstframe: FRAME_ATTAK301,
    lastframe: FRAME_ATTAK321,
    frames: &TANK_FRAMES_ATTACK_PRE_ROCKET,
    endfunc: Some(tank_doattack_rocket),
};

static TANK_FRAMES_ATTACK_FIRE_ROCKET: [MFrame; 9] = [
    MFrame { ai_fn: ai_charge, dist: -3.0, think_fn: None },          // Loop Start 22
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(tank_rocket) },   // 24
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(tank_rocket) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: Some(tank_rocket) },  // 30 Loop End
];

pub static TANK_MOVE_ATTACK_FIRE_ROCKET: MMove = MMove {
    firstframe: FRAME_ATTAK322,
    lastframe: FRAME_ATTAK330,
    frames: &TANK_FRAMES_ATTACK_FIRE_ROCKET,
    endfunc: Some(tank_refire_rocket),
};

static TANK_FRAMES_ATTACK_POST_ROCKET: [MFrame; 23] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },     // 31
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },    // 40
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -9.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -8.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -7.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: Some(tank_footstep) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },    // 50
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
];

pub static TANK_MOVE_ATTACK_POST_ROCKET: MMove = MMove {
    firstframe: FRAME_ATTAK331,
    lastframe: FRAME_ATTAK353,
    frames: &TANK_FRAMES_ATTACK_POST_ROCKET,
    endfunc: Some(tank_run),
};

// ============================================================
// Attack: machinegun chain animation
// Note: In C, frames 6-24 use NULL for ai_fn (no movement).
// We use ai_stand with dist 0.0 as equivalent (no movement).
// ============================================================

static TANK_FRAMES_ATTACK_CHAIN: [MFrame; 29] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },  // NULL ai_fn in C
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(tank_machinegun) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
];

pub static TANK_MOVE_ATTACK_CHAIN: MMove = MMove {
    firstframe: FRAME_ATTAK401,
    lastframe: FRAME_ATTAK429,
    frames: &TANK_FRAMES_ATTACK_CHAIN,
    endfunc: Some(tank_run),
};

fn tank_refire_rocket(self_ent: &mut Edict, ctx: &mut GameContext) {
    // Only on hard or nightmare
    if ctx.skill >= 2.0 {
        let enemy_opt = if self_ent.enemy >= 0 { Some(self_ent.enemy as usize) } else { None };
        let enemy_alive = if let Some(ei) = enemy_opt {
            ei < ctx.edicts.len() && ctx.edicts[ei].health > 0
        } else { false };
        if enemy_alive && visible(self_ent, enemy_opt) && random() <= 0.4 {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_FIRE_ROCKET);
            return;
        }
    }
    self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_POST_ROCKET);
}

fn tank_doattack_rocket(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_FIRE_ROCKET);
}

pub fn tank_attack(self_ent: &mut Edict, ctx: &mut GameContext) {
    // Check if enemy exists and its health
    if self_ent.enemy == 0 {
        return;
    }

    let enemy_idx = self_ent.enemy;
    if enemy_idx > 0 {
        let enemy_health = ctx.edicts[enemy_idx as usize].health;
        if enemy_health < 0 {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_STRIKE);
            self_ent.monsterinfo.aiflags &= !AI_BRUTAL;
            return;
        }
    }

    let enemy_origin = if enemy_idx > 0 {
        ctx.edicts[enemy_idx as usize].s.origin
    } else {
        self_ent.s.origin
    };
    let vec = [
        enemy_origin[0] - self_ent.s.origin[0],
        enemy_origin[1] - self_ent.s.origin[1],
        enemy_origin[2] - self_ent.s.origin[2],
    ];
    let range = vector_length(&vec);

    let r = random();

    if range <= 125.0 {
        if r < 0.4 {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_CHAIN);
        } else {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_BLAST);
        }
    } else if range <= 250.0 {
        if r < 0.5 {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_CHAIN);
        } else {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_BLAST);
        }
    } else if r < 0.33 {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_CHAIN);
    } else if r < 0.66 {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_PRE_ROCKET);
        self_ent.pain_debounce_time = ctx.level.time + 5.0; // no pain for a while
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_BLAST);
    }
}

// ============================================================
// Death animation
// ============================================================

fn tank_dead(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.mins = [-16.0, -16.0, -16.0];
    self_ent.maxs = [16.0, 16.0, 0.0];
    self_ent.movetype = MoveType::Toss;
    self_ent.svflags |= SVF_DEADMONSTER;
    self_ent.nextthink = 0.0;
    gi_linkentity(self_ent);
}

static TANK_FRAMES_DEATH1: [MFrame; 32] = [
    MFrame { ai_fn: ai_move, dist: -7.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -4.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -6.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -4.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -5.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -7.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -15.0, think_fn: Some(tank_thud) },
    MFrame { ai_fn: ai_move, dist: -5.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static TANK_MOVE_DEATH: MMove = MMove {
    firstframe: FRAME_DEATH101,
    lastframe: FRAME_DEATH132,
    frames: &TANK_FRAMES_DEATH1,
    endfunc: Some(tank_dead),
};

pub fn tank_die(self_ent: &mut Edict, _inflictor: &mut Edict, _attacker: &mut Edict, damage: i32, _point: [f32; 3], _ctx: &mut GameContext) {
    // check for gib
    if self_ent.health <= self_ent.gib_health {
        gi_sound(self_ent, CHAN_VOICE, gi_soundindex("misc/udeath.wav"), 1.0, ATTN_NORM, 0.0);
        for _n in 0..1 /* 4 in original, but commented to 1 */ {
            throw_gib(self_ent, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
        }
        for _n in 0..4 {
            throw_gib(self_ent, "models/objects/gibs/sm_metal/tris.md2", damage, GIB_METALLIC);
        }
        throw_gib(self_ent, "models/objects/gibs/chest/tris.md2", damage, GIB_ORGANIC);
        throw_head(self_ent, "models/objects/gibs/gear/tris.md2", damage, GIB_METALLIC);
        self_ent.deadflag = DEAD_DEAD;
        return;
    }

    if self_ent.deadflag == DEAD_DEAD {
        return;
    }

    // regular death
    let sound_die = SOUNDS.get().map_or(0, |s| s.die);
    gi_sound(self_ent, CHAN_VOICE, sound_die, 1.0, ATTN_NORM, 0.0);
    self_ent.deadflag = DEAD_DEAD;
    self_ent.takedamage = DAMAGE_YES;

    self_ent.monsterinfo.currentmove = Some(MOVE_DEATH);
}

// ============================================================
// SP_monster_tank / SP_monster_tank_commander
// ============================================================

pub fn sp_monster_tank(self_ent: &mut Edict, ctx: &mut GameContext) {
    if ctx.deathmatch != 0.0 {
        g_free_edict(self_ent);
        return;
    }

    self_ent.s.modelindex = gi_modelindex("models/monsters/tank/tris.md2");
    self_ent.mins = [-32.0, -32.0, -16.0];
    self_ent.maxs = [32.0, 32.0, 72.0];
    self_ent.movetype = MoveType::Step;
    self_ent.solid = Solid::Bbox;

    SOUNDS.get_or_init(|| TankSounds {
        pain: gi_soundindex("tank/tnkpain2.wav"),
        thud: gi_soundindex("tank/tnkdeth2.wav"),
        idle: gi_soundindex("tank/tnkidle1.wav"),
        die: gi_soundindex("tank/death.wav"),
        step: gi_soundindex("tank/step.wav"),
        windup: gi_soundindex("tank/tnkatck4.wav"),
        strike: gi_soundindex("tank/tnkatck5.wav"),
        sight: gi_soundindex("tank/sight1.wav"),
    });

    // Precache additional sounds
    gi_soundindex("tank/tnkatck1.wav");
    gi_soundindex("tank/tnkatk2a.wav");
    gi_soundindex("tank/tnkatk2b.wav");
    gi_soundindex("tank/tnkatk2c.wav");
    gi_soundindex("tank/tnkatk2d.wav");
    gi_soundindex("tank/tnkatk2e.wav");
    gi_soundindex("tank/tnkatck3.wav");

    if self_ent.classname == "monster_tank_commander" {
        self_ent.health = 1000;
        self_ent.gib_health = -225;
    } else {
        self_ent.health = 750;
        self_ent.gib_health = -200;
    }

    self_ent.mass = 500;

    self_ent.pain_fn = Some(crate::dispatch::PAIN_TANK);
    self_ent.die_fn = Some(crate::dispatch::DIE_TANK);

    self_ent.monsterinfo.stand_fn = Some(crate::dispatch::MSTAND_TANK);
    self_ent.monsterinfo.walk_fn = Some(crate::dispatch::MWALK_TANK);
    self_ent.monsterinfo.run_fn = Some(crate::dispatch::MRUN_TANK);
    self_ent.monsterinfo.dodge_fn = None;
    self_ent.monsterinfo.attack_fn = Some(crate::dispatch::MATTACK_TANK);
    self_ent.monsterinfo.melee_fn = None;
    self_ent.monsterinfo.sight_fn = Some(crate::dispatch::MSIGHT_TANK);
    self_ent.monsterinfo.idle_fn = Some(crate::dispatch::MIDLE_TANK);

    gi_linkentity(self_ent);

    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    self_ent.monsterinfo.scale = MODEL_SCALE;

    walkmonster_start(self_ent);

    if self_ent.classname == "monster_tank_commander" {
        self_ent.s.skinnum = 2;
    }
}
