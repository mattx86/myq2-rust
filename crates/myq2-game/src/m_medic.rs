// m_medic.rs — Medic monster
// Converted from: myq2-original/game/m_medic.c
// Frame definitions from: myq2-original/game/m_medic.h

use crate::g_local::*;
use crate::game::*;
use myq2_common::common::frand as random;
use crate::entity_adapters::{
    gi_sound, gi_soundindex, gi_modelindex, gi_linkentity,
    g_free_edict, walkmonster_start, throw_gib, throw_head,
    visible, monster_flash_offset, g_project_source,
    monster_fire_blaster, ed_call_spawn,
};
use crate::game_import::{skill_value, gi_write_byte, gi_write_short, gi_write_position, gi_multicast};

// ============================================================
// Frame definitions (from m_medic.h)
// This file generated by ModelGen - Do NOT Modify
// ============================================================

pub const FRAME_WALK1: i32 = 0;
pub const FRAME_WALK2: i32 = 1;
pub const FRAME_WALK3: i32 = 2;
pub const FRAME_WALK4: i32 = 3;
pub const FRAME_WALK5: i32 = 4;
pub const FRAME_WALK6: i32 = 5;
pub const FRAME_WALK7: i32 = 6;
pub const FRAME_WALK8: i32 = 7;
pub const FRAME_WALK9: i32 = 8;
pub const FRAME_WALK10: i32 = 9;
pub const FRAME_WALK11: i32 = 10;
pub const FRAME_WALK12: i32 = 11;
pub const FRAME_WAIT1: i32 = 12;
pub const FRAME_WAIT2: i32 = 13;
pub const FRAME_WAIT3: i32 = 14;
pub const FRAME_WAIT4: i32 = 15;
pub const FRAME_WAIT5: i32 = 16;
pub const FRAME_WAIT6: i32 = 17;
pub const FRAME_WAIT7: i32 = 18;
pub const FRAME_WAIT8: i32 = 19;
pub const FRAME_WAIT9: i32 = 20;
pub const FRAME_WAIT10: i32 = 21;
pub const FRAME_WAIT11: i32 = 22;
pub const FRAME_WAIT12: i32 = 23;
pub const FRAME_WAIT13: i32 = 24;
pub const FRAME_WAIT14: i32 = 25;
pub const FRAME_WAIT15: i32 = 26;
pub const FRAME_WAIT16: i32 = 27;
pub const FRAME_WAIT17: i32 = 28;
pub const FRAME_WAIT18: i32 = 29;
pub const FRAME_WAIT19: i32 = 30;
pub const FRAME_WAIT20: i32 = 31;
pub const FRAME_WAIT21: i32 = 32;
pub const FRAME_WAIT22: i32 = 33;
pub const FRAME_WAIT23: i32 = 34;
pub const FRAME_WAIT24: i32 = 35;
pub const FRAME_WAIT25: i32 = 36;
pub const FRAME_WAIT26: i32 = 37;
pub const FRAME_WAIT27: i32 = 38;
pub const FRAME_WAIT28: i32 = 39;
pub const FRAME_WAIT29: i32 = 40;
pub const FRAME_WAIT30: i32 = 41;
pub const FRAME_WAIT31: i32 = 42;
pub const FRAME_WAIT32: i32 = 43;
pub const FRAME_WAIT33: i32 = 44;
pub const FRAME_WAIT34: i32 = 45;
pub const FRAME_WAIT35: i32 = 46;
pub const FRAME_WAIT36: i32 = 47;
pub const FRAME_WAIT37: i32 = 48;
pub const FRAME_WAIT38: i32 = 49;
pub const FRAME_WAIT39: i32 = 50;
pub const FRAME_WAIT40: i32 = 51;
pub const FRAME_WAIT41: i32 = 52;
pub const FRAME_WAIT42: i32 = 53;
pub const FRAME_WAIT43: i32 = 54;
pub const FRAME_WAIT44: i32 = 55;
pub const FRAME_WAIT45: i32 = 56;
pub const FRAME_WAIT46: i32 = 57;
pub const FRAME_WAIT47: i32 = 58;
pub const FRAME_WAIT48: i32 = 59;
pub const FRAME_WAIT49: i32 = 60;
pub const FRAME_WAIT50: i32 = 61;
pub const FRAME_WAIT51: i32 = 62;
pub const FRAME_WAIT52: i32 = 63;
pub const FRAME_WAIT53: i32 = 64;
pub const FRAME_WAIT54: i32 = 65;
pub const FRAME_WAIT55: i32 = 66;
pub const FRAME_WAIT56: i32 = 67;
pub const FRAME_WAIT57: i32 = 68;
pub const FRAME_WAIT58: i32 = 69;
pub const FRAME_WAIT59: i32 = 70;
pub const FRAME_WAIT60: i32 = 71;
pub const FRAME_WAIT61: i32 = 72;
pub const FRAME_WAIT62: i32 = 73;
pub const FRAME_WAIT63: i32 = 74;
pub const FRAME_WAIT64: i32 = 75;
pub const FRAME_WAIT65: i32 = 76;
pub const FRAME_WAIT66: i32 = 77;
pub const FRAME_WAIT67: i32 = 78;
pub const FRAME_WAIT68: i32 = 79;
pub const FRAME_WAIT69: i32 = 80;
pub const FRAME_WAIT70: i32 = 81;
pub const FRAME_WAIT71: i32 = 82;
pub const FRAME_WAIT72: i32 = 83;
pub const FRAME_WAIT73: i32 = 84;
pub const FRAME_WAIT74: i32 = 85;
pub const FRAME_WAIT75: i32 = 86;
pub const FRAME_WAIT76: i32 = 87;
pub const FRAME_WAIT77: i32 = 88;
pub const FRAME_WAIT78: i32 = 89;
pub const FRAME_WAIT79: i32 = 90;
pub const FRAME_WAIT80: i32 = 91;
pub const FRAME_WAIT81: i32 = 92;
pub const FRAME_WAIT82: i32 = 93;
pub const FRAME_WAIT83: i32 = 94;
pub const FRAME_WAIT84: i32 = 95;
pub const FRAME_WAIT85: i32 = 96;
pub const FRAME_WAIT86: i32 = 97;
pub const FRAME_WAIT87: i32 = 98;
pub const FRAME_WAIT88: i32 = 99;
pub const FRAME_WAIT89: i32 = 100;
pub const FRAME_WAIT90: i32 = 101;
pub const FRAME_RUN1: i32 = 102;
pub const FRAME_RUN2: i32 = 103;
pub const FRAME_RUN3: i32 = 104;
pub const FRAME_RUN4: i32 = 105;
pub const FRAME_RUN5: i32 = 106;
pub const FRAME_RUN6: i32 = 107;
pub const FRAME_PAINA1: i32 = 108;
pub const FRAME_PAINA2: i32 = 109;
pub const FRAME_PAINA3: i32 = 110;
pub const FRAME_PAINA4: i32 = 111;
pub const FRAME_PAINA5: i32 = 112;
pub const FRAME_PAINA6: i32 = 113;
pub const FRAME_PAINA7: i32 = 114;
pub const FRAME_PAINA8: i32 = 115;
pub const FRAME_PAINB1: i32 = 116;
pub const FRAME_PAINB2: i32 = 117;
pub const FRAME_PAINB3: i32 = 118;
pub const FRAME_PAINB4: i32 = 119;
pub const FRAME_PAINB5: i32 = 120;
pub const FRAME_PAINB6: i32 = 121;
pub const FRAME_PAINB7: i32 = 122;
pub const FRAME_PAINB8: i32 = 123;
pub const FRAME_PAINB9: i32 = 124;
pub const FRAME_PAINB10: i32 = 125;
pub const FRAME_PAINB11: i32 = 126;
pub const FRAME_PAINB12: i32 = 127;
pub const FRAME_PAINB13: i32 = 128;
pub const FRAME_PAINB14: i32 = 129;
pub const FRAME_PAINB15: i32 = 130;
pub const FRAME_DUCK1: i32 = 131;
pub const FRAME_DUCK2: i32 = 132;
pub const FRAME_DUCK3: i32 = 133;
pub const FRAME_DUCK4: i32 = 134;
pub const FRAME_DUCK5: i32 = 135;
pub const FRAME_DUCK6: i32 = 136;
pub const FRAME_DUCK7: i32 = 137;
pub const FRAME_DUCK8: i32 = 138;
pub const FRAME_DUCK9: i32 = 139;
pub const FRAME_DUCK10: i32 = 140;
pub const FRAME_DUCK11: i32 = 141;
pub const FRAME_DUCK12: i32 = 142;
pub const FRAME_DUCK13: i32 = 143;
pub const FRAME_DUCK14: i32 = 144;
pub const FRAME_DUCK15: i32 = 145;
pub const FRAME_DUCK16: i32 = 146;
pub const FRAME_DEATH1: i32 = 147;
pub const FRAME_DEATH2: i32 = 148;
pub const FRAME_DEATH3: i32 = 149;
pub const FRAME_DEATH4: i32 = 150;
pub const FRAME_DEATH5: i32 = 151;
pub const FRAME_DEATH6: i32 = 152;
pub const FRAME_DEATH7: i32 = 153;
pub const FRAME_DEATH8: i32 = 154;
pub const FRAME_DEATH9: i32 = 155;
pub const FRAME_DEATH10: i32 = 156;
pub const FRAME_DEATH11: i32 = 157;
pub const FRAME_DEATH12: i32 = 158;
pub const FRAME_DEATH13: i32 = 159;
pub const FRAME_DEATH14: i32 = 160;
pub const FRAME_DEATH15: i32 = 161;
pub const FRAME_DEATH16: i32 = 162;
pub const FRAME_DEATH17: i32 = 163;
pub const FRAME_DEATH18: i32 = 164;
pub const FRAME_DEATH19: i32 = 165;
pub const FRAME_DEATH20: i32 = 166;
pub const FRAME_DEATH21: i32 = 167;
pub const FRAME_DEATH22: i32 = 168;
pub const FRAME_DEATH23: i32 = 169;
pub const FRAME_DEATH24: i32 = 170;
pub const FRAME_DEATH25: i32 = 171;
pub const FRAME_DEATH26: i32 = 172;
pub const FRAME_DEATH27: i32 = 173;
pub const FRAME_DEATH28: i32 = 174;
pub const FRAME_DEATH29: i32 = 175;
pub const FRAME_DEATH30: i32 = 176;
pub const FRAME_ATTACK1: i32 = 177;
pub const FRAME_ATTACK2: i32 = 178;
pub const FRAME_ATTACK3: i32 = 179;
pub const FRAME_ATTACK4: i32 = 180;
pub const FRAME_ATTACK5: i32 = 181;
pub const FRAME_ATTACK6: i32 = 182;
pub const FRAME_ATTACK7: i32 = 183;
pub const FRAME_ATTACK8: i32 = 184;
pub const FRAME_ATTACK9: i32 = 185;
pub const FRAME_ATTACK10: i32 = 186;
pub const FRAME_ATTACK11: i32 = 187;
pub const FRAME_ATTACK12: i32 = 188;
pub const FRAME_ATTACK13: i32 = 189;
pub const FRAME_ATTACK14: i32 = 190;
pub const FRAME_ATTACK15: i32 = 191;
pub const FRAME_ATTACK16: i32 = 192;
pub const FRAME_ATTACK17: i32 = 193;
pub const FRAME_ATTACK18: i32 = 194;
pub const FRAME_ATTACK19: i32 = 195;
pub const FRAME_ATTACK20: i32 = 196;
pub const FRAME_ATTACK21: i32 = 197;
pub const FRAME_ATTACK22: i32 = 198;
pub const FRAME_ATTACK23: i32 = 199;
pub const FRAME_ATTACK24: i32 = 200;
pub const FRAME_ATTACK25: i32 = 201;
pub const FRAME_ATTACK26: i32 = 202;
pub const FRAME_ATTACK27: i32 = 203;
pub const FRAME_ATTACK28: i32 = 204;
pub const FRAME_ATTACK29: i32 = 205;
pub const FRAME_ATTACK30: i32 = 206;
pub const FRAME_ATTACK31: i32 = 207;
pub const FRAME_ATTACK32: i32 = 208;
pub const FRAME_ATTACK33: i32 = 209;
pub const FRAME_ATTACK34: i32 = 210;
pub const FRAME_ATTACK35: i32 = 211;
pub const FRAME_ATTACK36: i32 = 212;
pub const FRAME_ATTACK37: i32 = 213;
pub const FRAME_ATTACK38: i32 = 214;
pub const FRAME_ATTACK39: i32 = 215;
pub const FRAME_ATTACK40: i32 = 216;
pub const FRAME_ATTACK41: i32 = 217;
pub const FRAME_ATTACK42: i32 = 218;
pub const FRAME_ATTACK43: i32 = 219;
pub const FRAME_ATTACK44: i32 = 220;
pub const FRAME_ATTACK45: i32 = 221;
pub const FRAME_ATTACK46: i32 = 222;
pub const FRAME_ATTACK47: i32 = 223;
pub const FRAME_ATTACK48: i32 = 224;
pub const FRAME_ATTACK49: i32 = 225;
pub const FRAME_ATTACK50: i32 = 226;
pub const FRAME_ATTACK51: i32 = 227;
pub const FRAME_ATTACK52: i32 = 228;
pub const FRAME_ATTACK53: i32 = 229;
pub const FRAME_ATTACK54: i32 = 230;
pub const FRAME_ATTACK55: i32 = 231;
pub const FRAME_ATTACK56: i32 = 232;
pub const FRAME_ATTACK57: i32 = 233;
pub const FRAME_ATTACK58: i32 = 234;
pub const FRAME_ATTACK59: i32 = 235;
pub const FRAME_ATTACK60: i32 = 236;

pub const MODEL_SCALE: f32 = 1.0;

// ============================================================
// Sound / effect / protocol constants
// ============================================================

// CHAN_*, ATTN_*, EF_* come from g_local::* re-export (myq2_common::q_shared)

// SVC_TEMP_ENTITY, TE_MEDIC_CABLE_ATTACK come from g_local::* re-export

const MZ2_MEDIC_BLASTER_1: i32 = 100;

use myq2_common::q_shared::{MASK_SHOT, vector_subtract, vector_length, vector_ma};
// MULTICAST_PVS comes from g_local::*

// ============================================================
// Move table index constants
// ============================================================

pub const MOVE_STAND: usize = 0;
pub const MOVE_WALK: usize = 1;
pub const MOVE_RUN: usize = 2;
pub const MOVE_PAIN1: usize = 3;
pub const MOVE_PAIN2: usize = 4;
pub const MOVE_DEATH: usize = 5;
pub const MOVE_DUCK: usize = 6;
pub const MOVE_ATTACK_BLASTER: usize = 7;
pub const MOVE_ATTACK_HYPER_BLASTER: usize = 8;
pub const MOVE_ATTACK_CABLE: usize = 9;

use crate::ai_wrappers::{ai_stand, ai_walk, ai_run, ai_charge, ai_move};

// ============================================================
// Sound indices (module-level state, replaces C statics)
// ============================================================

#[derive(Default)]
pub struct MedicSounds {
    pub idle1: i32,
    pub pain1: i32,
    pub pain2: i32,
    pub die: i32,
    pub sight: i32,
    pub search: i32,
    pub hook_launch: i32,
    pub hook_hit: i32,
    pub hook_heal: i32,
    pub hook_retract: i32,
}

static SOUNDS: std::sync::OnceLock<MedicSounds> = std::sync::OnceLock::new();


fn found_target_by_idx(self_idx: i32) {
    crate::g_local::with_global_game_ctx(|ctx| {
        use std::mem;
        let mut ai_ctx = crate::g_ai::AiContext {
            edicts: mem::take(&mut ctx.edicts),
            clients: mem::take(&mut ctx.clients),
            level: mem::take(&mut ctx.level),
            game: mem::take(&mut ctx.game),
            coop: ctx.coop,
            skill: ctx.skill,
            enemy_vis: false,
            enemy_infront: false,
            enemy_range: 0,
            enemy_yaw: 0.0,
        };
        crate::g_ai::found_target(&mut ai_ctx, self_idx);
        ctx.edicts = ai_ctx.edicts;
        ctx.clients = ai_ctx.clients;
        ctx.level = ai_ctx.level;
        ctx.game = ai_ctx.game;
    });
}


fn m_check_attack(self_ent: &mut Edict) -> bool {
    let self_idx = self_ent.s.number;
    crate::g_local::with_global_game_ctx(|ctx| {
        use std::mem;
        let mut ai_ctx = crate::g_ai::AiContext {
            edicts: mem::take(&mut ctx.edicts),
            clients: mem::take(&mut ctx.clients),
            level: mem::take(&mut ctx.level),
            game: mem::take(&mut ctx.game),
            coop: ctx.coop,
            skill: ctx.skill,
            enemy_vis: false,
            enemy_infront: false,
            enemy_range: 0,
            enemy_yaw: 0.0,
        };
        let result = crate::g_ai::m_check_attack(&mut ai_ctx, self_idx);
        ctx.edicts = ai_ctx.edicts;
        ctx.clients = ai_ctx.clients;
        ctx.level = ai_ctx.level;
        ctx.game = ai_ctx.game;
        result
    }).unwrap_or(false)
}

use myq2_common::q_shared::angle_vectors;

use crate::g_utils::vectoangles;



// ============================================================
// Cable offsets table
// ============================================================

static MEDIC_CABLE_OFFSETS: [[f32; 3]; 10] = [
    [45.0, -9.2, 15.5],
    [48.4, -9.7, 15.2],
    [47.8, -9.8, 15.8],
    [47.3, -9.3, 14.3],
    [45.4, -10.1, 13.1],
    [41.9, -12.7, 12.0],
    [37.8, -15.8, 11.2],
    [34.3, -18.4, 10.7],
    [32.7, -19.7, 10.4],
    [32.7, -19.7, 10.4],
];

// ============================================================
// Medic behavior functions
// ============================================================

/// Find a dead monster within 1024 units that the medic can resurrect.
/// Returns the entity index of the best candidate, or None.
pub fn medic_find_dead_monster(self_idx: usize, edicts: &[Edict]) -> Option<usize> {
    let self_origin = edicts[self_idx].s.origin;
    let mut best: Option<usize> = None;
    let mut best_max_health: i32 = 0;

    let candidates = crate::g_combat::findradius(None, self_origin, 1024.0, edicts);
    for ent_idx in candidates {
        if ent_idx == self_idx {
            continue;
        }
        if (edicts[ent_idx].svflags & SVF_MONSTER) == 0 {
            continue;
        }
        if edicts[ent_idx].monsterinfo.aiflags.intersects(AI_GOOD_GUY) {
            continue;
        }
        if edicts[ent_idx].owner >= 0 {
            continue;
        }
        if edicts[ent_idx].health > 0 {
            continue;
        }
        if edicts[ent_idx].nextthink != 0.0 {
            continue;
        }
        if !visible(&edicts[self_idx], &edicts[ent_idx]) {
            continue;
        }
        match best {
            None => {
                best = Some(ent_idx);
                best_max_health = edicts[ent_idx].max_health;
            }
            Some(_) => {
                if edicts[ent_idx].max_health > best_max_health {
                    best = Some(ent_idx);
                    best_max_health = edicts[ent_idx].max_health;
                }
            }
        }
    }

    best
}

pub fn medic_idle(self_ent: &mut Edict, _ctx: &mut GameContext) {
    // SAFETY: sound indices initialized in SP_monster_medic
    let sound_idle1 = SOUNDS.get().map_or(0, |s| s.idle1);
    gi_sound(self_ent, CHAN_VOICE, sound_idle1, 1.0, ATTN_IDLE, 0.0);

    let self_idx = self_ent.s.number as usize;
    if let Some(ent_idx) = medic_find_dead_monster(self_idx, &_ctx.edicts) {
        self_ent.enemy = ent_idx as i32;
        _ctx.edicts[ent_idx].owner = self_idx as i32;
        self_ent.monsterinfo.aiflags |= AI_MEDIC;
        found_target_by_idx(self_ent.s.number);
    }
}

pub fn medic_search(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_search = SOUNDS.get().map_or(0, |s| s.search);
    gi_sound(self_ent, CHAN_VOICE, sound_search, 1.0, ATTN_IDLE, 0.0);

    if self_ent.oldenemy < 0 {
        let self_idx = self_ent.s.number as usize;
        if let Some(ent_idx) = medic_find_dead_monster(self_idx, &_ctx.edicts) {
            self_ent.oldenemy = self_ent.enemy;
            self_ent.enemy = ent_idx as i32;
            _ctx.edicts[ent_idx].owner = self_idx as i32;
            self_ent.monsterinfo.aiflags |= AI_MEDIC;
            found_target_by_idx(self_ent.s.number);
        }
    }
}

pub fn medic_sight(self_ent: &mut Edict, _other: &mut Edict) {
    let sound_sight = SOUNDS.get().map_or(0, |s| s.sight);
    gi_sound(self_ent, CHAN_VOICE, sound_sight, 1.0, ATTN_NORM, 0.0);
}

// ============================================================
// Stand animation (90 frames: wait1..wait90)
// ============================================================

static MEDIC_FRAMES_STAND: [MFrame; 90] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(medic_idle) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static MEDIC_MOVE_STAND: MMove = MMove {
    firstframe: FRAME_WAIT1,
    lastframe: FRAME_WAIT90,
    frames: &MEDIC_FRAMES_STAND,
    endfunc: None,
};

pub fn medic_stand(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
}

// ============================================================
// Walk animation (12 frames)
// ============================================================

static MEDIC_FRAMES_WALK: [MFrame; 12] = [
    MFrame { ai_fn: ai_walk, dist: 6.2, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 18.1, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 9.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 9.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 11.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 11.6, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 9.9, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 14.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 9.3, think_fn: None },
];

pub static MEDIC_MOVE_WALK: MMove = MMove {
    firstframe: FRAME_WALK1,
    lastframe: FRAME_WALK12,
    frames: &MEDIC_FRAMES_WALK,
    endfunc: None,
};

pub fn medic_walk(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_WALK);
}

// ============================================================
// Run animation (6 frames)
// ============================================================

static MEDIC_FRAMES_RUN: [MFrame; 6] = [
    MFrame { ai_fn: ai_run, dist: 18.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 22.5, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 25.4, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 23.4, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 24.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 35.6, think_fn: None },
];

pub static MEDIC_MOVE_RUN: MMove = MMove {
    firstframe: FRAME_RUN1,
    lastframe: FRAME_RUN6,
    frames: &MEDIC_FRAMES_RUN,
    endfunc: None,
};

pub fn medic_run(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if !self_ent.monsterinfo.aiflags.intersects(AI_MEDIC) {
        let self_idx = self_ent.s.number as usize;
        if let Some(ent_idx) = medic_find_dead_monster(self_idx, &_ctx.edicts) {
            self_ent.oldenemy = self_ent.enemy;
            self_ent.enemy = ent_idx as i32;
            _ctx.edicts[ent_idx].owner = self_idx as i32;
            self_ent.monsterinfo.aiflags |= AI_MEDIC;
            found_target_by_idx(self_ent.s.number);
        }
    }

    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_RUN);
    }
}

// ============================================================
// Pain animations
// ============================================================

static MEDIC_FRAMES_PAIN1: [MFrame; 8] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static MEDIC_MOVE_PAIN1: MMove = MMove {
    firstframe: FRAME_PAINA1,
    lastframe: FRAME_PAINA8,
    frames: &MEDIC_FRAMES_PAIN1,
    endfunc: Some(medic_run),
};

static MEDIC_FRAMES_PAIN2: [MFrame; 15] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static MEDIC_MOVE_PAIN2: MMove = MMove {
    firstframe: FRAME_PAINB1,
    lastframe: FRAME_PAINB15,
    frames: &MEDIC_FRAMES_PAIN2,
    endfunc: Some(medic_run),
};

pub fn medic_pain(self_ent: &mut Edict, _other: &mut Edict, _kick: f32, _damage: i32, ctx: &mut GameContext) {
    if self_ent.health < (self_ent.max_health / 2) {
        self_ent.s.skinnum = 1;
    }

    if ctx.level.time < self_ent.pain_debounce_time {
        return;
    }

    self_ent.pain_debounce_time = ctx.level.time + 3.0;

    // skill->value == 3 means nightmare: no pain anims
    if skill_value() == 3.0 {
        return; // no pain anims in nightmare
    }

    if random() < 0.5 {
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN1);
        let sound_pain1 = SOUNDS.get().map_or(0, |s| s.pain1);
        gi_sound(self_ent, CHAN_VOICE, sound_pain1, 1.0, ATTN_NORM, 0.0);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN2);
        let sound_pain2 = SOUNDS.get().map_or(0, |s| s.pain2);
        gi_sound(self_ent, CHAN_VOICE, sound_pain2, 1.0, ATTN_NORM, 0.0);
    }
}

// ============================================================
// Fire blaster
// ============================================================

pub fn medic_fire_blaster(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let effect: i32;

    if self_ent.s.frame == FRAME_ATTACK9 || self_ent.s.frame == FRAME_ATTACK12 {
        effect = EF_BLASTER as i32;
    } else if self_ent.s.frame == FRAME_ATTACK19
        || self_ent.s.frame == FRAME_ATTACK22
        || self_ent.s.frame == FRAME_ATTACK25
        || self_ent.s.frame == FRAME_ATTACK28
    {
        effect = EF_HYPERBLASTER as i32;
    } else {
        effect = 0;
    }

    let mut forward = [0.0_f32; 3];
    let mut right = [0.0_f32; 3];
    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);

    let mut start = [0.0_f32; 3];
    let flash_offset = monster_flash_offset(MZ2_MEDIC_BLASTER_1);
    g_project_source(&self_ent.s.origin, &flash_offset, &forward, &right, &mut start);

    let enemy_idx = self_ent.enemy;
    if enemy_idx >= 0 {
        let enemy = &_ctx.edicts[enemy_idx as usize];
        let mut end = enemy.s.origin;
        end[2] += enemy.viewheight as f32;
        let dir = vector_subtract(&end, &start);
        monster_fire_blaster(self_ent, start, dir, 2, 1000, MZ2_MEDIC_BLASTER_1, effect);
    }
}

// ============================================================
// Death
// ============================================================

fn medic_dead(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.mins = [-16.0, -16.0, -24.0];
    self_ent.maxs = [16.0, 16.0, -8.0];
    self_ent.movetype = MoveType::Toss;
    self_ent.svflags |= SVF_DEADMONSTER;
    self_ent.nextthink = 0.0;
    gi_linkentity(self_ent);
}

static MEDIC_FRAMES_DEATH: [MFrame; 30] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static MEDIC_MOVE_DEATH: MMove = MMove {
    firstframe: FRAME_DEATH1,
    lastframe: FRAME_DEATH30,
    frames: &MEDIC_FRAMES_DEATH,
    endfunc: Some(medic_dead),
};

pub fn medic_die(self_ent: &mut Edict, _inflictor: &mut Edict, _attacker: &mut Edict, damage: i32, _point: [f32; 3], _ctx: &mut GameContext) {
    // if we had a pending patient, free him up for another medic
    // Release pending patient: if we had one, free him up for another medic
    let enemy_idx = self_ent.enemy;
    let self_idx = self_ent.s.number as i32;
    if enemy_idx >= 0 {
        let enemy = &mut _ctx.edicts[enemy_idx as usize];
        if enemy.owner == self_idx {
            enemy.owner = -1;
        }
    }

    // check for gib
    if self_ent.health <= self_ent.gib_health {
        gi_sound(self_ent, CHAN_VOICE, gi_soundindex("misc/udeath.wav"), 1.0, ATTN_NORM, 0.0);
        for _ in 0..2 {
            throw_gib(self_ent, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
        }
        for _ in 0..4 {
            throw_gib(self_ent, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
        }
        throw_head(self_ent, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
        self_ent.deadflag = DEAD_DEAD;
        return;
    }

    if self_ent.deadflag == DEAD_DEAD {
        return;
    }

    // regular death
    let sound_die = SOUNDS.get().map_or(0, |s| s.die);
    gi_sound(self_ent, CHAN_VOICE, sound_die, 1.0, ATTN_NORM, 0.0);
    self_ent.deadflag = DEAD_DEAD;
    self_ent.takedamage = Damage::Yes as i32;

    self_ent.monsterinfo.currentmove = Some(MOVE_DEATH);
}

// ============================================================
// Duck (dodge)
// ============================================================

fn medic_duck_down(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_DUCKED) {
        return;
    }
    self_ent.monsterinfo.aiflags |= AI_DUCKED;
    self_ent.maxs[2] -= 32.0;
    self_ent.takedamage = Damage::Yes as i32;
    self_ent.monsterinfo.pausetime = _ctx.level.time + 1.0;
    gi_linkentity(self_ent);
}

fn medic_duck_hold(self_ent: &mut Edict, ctx: &mut GameContext) {
    if ctx.level.time >= self_ent.monsterinfo.pausetime {
        self_ent.monsterinfo.aiflags &= !AI_HOLD_FRAME;
    } else {
        self_ent.monsterinfo.aiflags |= AI_HOLD_FRAME;
    }
}

fn medic_duck_up(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.aiflags &= !AI_DUCKED;
    self_ent.maxs[2] += 32.0;
    self_ent.takedamage = Damage::Aim as i32;
    gi_linkentity(self_ent);
}

static MEDIC_FRAMES_DUCK: [MFrame; 16] = [
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: Some(medic_duck_down) },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: Some(medic_duck_hold) },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: Some(medic_duck_up) },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
];

pub static MEDIC_MOVE_DUCK: MMove = MMove {
    firstframe: FRAME_DUCK1,
    lastframe: FRAME_DUCK16,
    frames: &MEDIC_FRAMES_DUCK,
    endfunc: Some(medic_run),
};

pub fn medic_dodge(self_ent: &mut Edict, _attacker: &mut Edict, _eta: f32, _ctx: &mut GameContext) {
    if random() > 0.25 {
        return;
    }

    if self_ent.enemy < 0 {
        self_ent.enemy = _attacker.s.number;
        found_target_by_idx(self_ent.s.number);
    }

    self_ent.monsterinfo.currentmove = Some(MOVE_DUCK);
}

// ============================================================
// Attack: HyperBlaster (frames attack15..attack30)
// ============================================================

static MEDIC_FRAMES_ATTACK_HYPER_BLASTER: [MFrame; 16] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
];

pub static MEDIC_MOVE_ATTACK_HYPER_BLASTER: MMove = MMove {
    firstframe: FRAME_ATTACK15,
    lastframe: FRAME_ATTACK30,
    frames: &MEDIC_FRAMES_ATTACK_HYPER_BLASTER,
    endfunc: Some(medic_run),
};

// ============================================================
// medic_continue — decide whether to keep firing hyperblaster
// ============================================================

fn medic_continue(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let enemy_idx = self_ent.enemy;
    let enemy_visible = if enemy_idx >= 0 {
        visible(self_ent, &_ctx.edicts[enemy_idx as usize])
    } else {
        false
    };
    if enemy_visible && random() <= 0.95 {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_HYPER_BLASTER);
    }
}

// ============================================================
// Attack: Blaster (frames attack1..attack14)
// ============================================================

static MEDIC_FRAMES_ATTACK_BLASTER: [MFrame; 14] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_fire_blaster) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(medic_continue) }, // Change to medic_continue... Else, go to frame 32
];

pub static MEDIC_MOVE_ATTACK_BLASTER: MMove = MMove {
    firstframe: FRAME_ATTACK1,
    lastframe: FRAME_ATTACK14,
    frames: &MEDIC_FRAMES_ATTACK_BLASTER,
    endfunc: Some(medic_run),
};

// ============================================================
// Cable attack (healing / resurrection)
// ============================================================

fn medic_hook_launch(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_hook_launch = SOUNDS.get().map_or(0, |s| s.hook_launch);
    gi_sound(self_ent, CHAN_WEAPON, sound_hook_launch, 1.0, ATTN_NORM, 0.0);
}

fn medic_cable_attack(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let enemy_idx = self_ent.enemy;
    if enemy_idx < 0 {
        return;
    }
    let enemy = &_ctx.edicts[enemy_idx as usize];
    if !enemy.inuse {
        return;
    }

    let frame = self_ent.s.frame;
    let cable_index = (frame - FRAME_ATTACK42) as usize;
    if cable_index >= MEDIC_CABLE_OFFSETS.len() {
        return;
    }

    let mut forward = [0.0_f32; 3];
    let mut right = [0.0_f32; 3];
    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);

    let offset = MEDIC_CABLE_OFFSETS[cable_index];
    let mut start = [0.0_f32; 3];
    g_project_source(&self_ent.s.origin, &offset, &forward, &right, &mut start);

    // distance check
    let dir = vector_subtract(&enemy.s.origin, &start);
    let distance = vector_length(&dir);
    if distance > 256.0 {
        return;
    }

    // pitch check
    let mut angles = [0.0_f32; 3];
    vectoangles(&dir, &mut angles);
    if angles[0].abs() > 45.0 {
        return;
    }

    // line of sight trace
    let tr = crate::game_import::gi_trace(&start, &[0.0; 3], &[0.0; 3], &enemy.s.origin, self_ent.s.number as i32, MASK_SHOT);
    if tr.fraction < 1.0 && tr.ent_index != enemy_idx as i32 {
        return;
    }

    if frame == FRAME_ATTACK43 {
        let sound_hook_hit = SOUNDS.get().map_or(0, |s| s.hook_hit);
        gi_sound(self_ent, CHAN_WEAPON, sound_hook_hit, 1.0, ATTN_NORM, 0.0);
        _ctx.edicts[enemy_idx as usize].monsterinfo.aiflags |= AI_RESURRECTING;
    } else if frame == FRAME_ATTACK50 {
        // Respawn the enemy (healing complete)
        _ctx.edicts[enemy_idx as usize].spawnflags = 0;
        _ctx.edicts[enemy_idx as usize].monsterinfo.aiflags = AiFlags::empty();
        _ctx.edicts[enemy_idx as usize].target = String::new();
        _ctx.edicts[enemy_idx as usize].targetname = String::new();
        _ctx.edicts[enemy_idx as usize].combattarget = String::new();
        _ctx.edicts[enemy_idx as usize].deathtarget = String::new();
        _ctx.edicts[enemy_idx as usize].owner = -1;
        ed_call_spawn(&mut _ctx.edicts[enemy_idx as usize]);
        _ctx.edicts[enemy_idx as usize].owner = -1;

        self_ent.monsterinfo.aiflags &= !AI_MEDIC;
        // Set the resurrected monster's enemy
        if self_ent.oldenemy >= 0 && _ctx.edicts[self_ent.oldenemy as usize].inuse {
            _ctx.edicts[enemy_idx as usize].enemy = self_ent.oldenemy;
            found_target_by_idx(enemy_idx);
        }
    } else if frame == FRAME_ATTACK44 {
        let sound_hook_heal = SOUNDS.get().map_or(0, |s| s.hook_heal);
        gi_sound(self_ent, CHAN_WEAPON, sound_hook_heal, 1.0, ATTN_NORM, 0.0);
    }

    // Adjust start for beam origin
    start = vector_ma(&start, 8.0, &forward);

    // Compute end position (enemy center)
    let enemy = &_ctx.edicts[enemy_idx as usize];
    let mut end = enemy.s.origin;
    end[2] = enemy.absmin[2] + enemy.size[2] / 2.0;

    // Send cable attack temp entity
    let self_idx = self_ent.s.number as i32;
    gi_write_byte(SVC_TEMP_ENTITY);
    gi_write_byte(TE_MEDIC_CABLE_ATTACK);
    gi_write_short(self_idx);
    gi_write_position(&start);
    gi_write_position(&end);
    gi_multicast(&self_ent.s.origin, MULTICAST_PVS);
}

fn medic_hook_retract(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_hook_retract = SOUNDS.get().map_or(0, |s| s.hook_retract);
    gi_sound(self_ent, CHAN_WEAPON, sound_hook_retract, 1.0, ATTN_NORM, 0.0);
    let enemy_idx = self_ent.enemy;
    if enemy_idx >= 0 {
        _ctx.edicts[enemy_idx as usize].monsterinfo.aiflags &= !AI_RESURRECTING;
    }
}

static MEDIC_FRAMES_ATTACK_CABLE: [MFrame; 28] = [
    MFrame { ai_fn: ai_move, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 4.4, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 4.7, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_hook_launch) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_cable_attack) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_cable_attack) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_cable_attack) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_cable_attack) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_cable_attack) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_cable_attack) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_cable_attack) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_cable_attack) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(medic_cable_attack) },
    MFrame { ai_fn: ai_move, dist: -15.0, think_fn: Some(medic_hook_retract) },
    MFrame { ai_fn: ai_move, dist: -1.5, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.2, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.3, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.7, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.2, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.3, think_fn: None },
];

pub static MEDIC_MOVE_ATTACK_CABLE: MMove = MMove {
    firstframe: FRAME_ATTACK33,
    lastframe: FRAME_ATTACK60,
    frames: &MEDIC_FRAMES_ATTACK_CABLE,
    endfunc: Some(medic_run),
};

// ============================================================
// Attack dispatch
// ============================================================

pub fn medic_attack(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_MEDIC) {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_CABLE);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_BLASTER);
    }
}

pub fn medic_checkattack(self_ent: &mut Edict, _ctx: &mut GameContext) -> bool {
    if self_ent.monsterinfo.aiflags.intersects(AI_MEDIC) {
        medic_attack(self_ent, _ctx);
        return true;
    }

    m_check_attack(self_ent)
}

// ============================================================
// Spawn function
// ============================================================

/// QUAKED monster_medic (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
pub fn sp_monster_medic(self_ent: &mut Edict, ctx: &mut GameContext) {
    if ctx.deathmatch != 0.0 {
        g_free_edict(self_ent);
        return;
    }

    SOUNDS.get_or_init(|| MedicSounds {
        idle1: gi_soundindex("medic/idle.wav"),
        pain1: gi_soundindex("medic/medpain1.wav"),
        pain2: gi_soundindex("medic/medpain2.wav"),
        die: gi_soundindex("medic/meddeth1.wav"),
        sight: gi_soundindex("medic/medsght1.wav"),
        search: gi_soundindex("medic/medsrch1.wav"),
        hook_launch: gi_soundindex("medic/medatck2.wav"),
        hook_hit: gi_soundindex("medic/medatck3.wav"),
        hook_heal: gi_soundindex("medic/medatck4.wav"),
        hook_retract: gi_soundindex("medic/medatck5.wav"),
    });

    gi_soundindex("medic/medatck1.wav"); // precache only

    self_ent.movetype = MoveType::Step;
    self_ent.solid = Solid::Bbox;
    self_ent.s.modelindex = gi_modelindex("models/monsters/medic/tris.md2");
    self_ent.mins = [-24.0, -24.0, -24.0];
    self_ent.maxs = [24.0, 24.0, 32.0];

    self_ent.health = 300;
    self_ent.gib_health = -130;
    self_ent.mass = 400;

    self_ent.pain_fn = Some(crate::dispatch::PAIN_MEDIC);
    self_ent.die_fn = Some(crate::dispatch::DIE_MEDIC);

    self_ent.monsterinfo.stand_fn = Some(crate::dispatch::MSTAND_MEDIC);
    self_ent.monsterinfo.walk_fn = Some(crate::dispatch::MWALK_MEDIC);
    self_ent.monsterinfo.run_fn = Some(crate::dispatch::MRUN_MEDIC);
    self_ent.monsterinfo.dodge_fn = Some(crate::dispatch::MDODGE_MEDIC);
    self_ent.monsterinfo.attack_fn = Some(crate::dispatch::MATTACK_MEDIC);
    self_ent.monsterinfo.melee_fn = None;
    self_ent.monsterinfo.sight_fn = Some(crate::dispatch::MSIGHT_MEDIC);
    self_ent.monsterinfo.idle_fn = Some(crate::dispatch::MIDLE_MEDIC);
    self_ent.monsterinfo.search_fn = Some(crate::dispatch::MSEARCH_MEDIC);
    self_ent.monsterinfo.checkattack_fn = Some(crate::dispatch::MCHECKATTACK_MEDIC);

    gi_linkentity(self_ent);

    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    self_ent.monsterinfo.scale = MODEL_SCALE;

    walkmonster_start(self_ent);
}

// ============================================================
// Move table: maps move indices to MMove statics
// ============================================================

/// Returns the MMove for a given medic move index.
pub fn medic_get_move(index: usize) -> Option<&'static MMove> {
    match index {
        MOVE_STAND => Some(&MEDIC_MOVE_STAND),
        MOVE_WALK => Some(&MEDIC_MOVE_WALK),
        MOVE_RUN => Some(&MEDIC_MOVE_RUN),
        MOVE_PAIN1 => Some(&MEDIC_MOVE_PAIN1),
        MOVE_PAIN2 => Some(&MEDIC_MOVE_PAIN2),
        MOVE_DEATH => Some(&MEDIC_MOVE_DEATH),
        MOVE_DUCK => Some(&MEDIC_MOVE_DUCK),
        MOVE_ATTACK_BLASTER => Some(&MEDIC_MOVE_ATTACK_BLASTER),
        MOVE_ATTACK_HYPER_BLASTER => Some(&MEDIC_MOVE_ATTACK_HYPER_BLASTER),
        MOVE_ATTACK_CABLE => Some(&MEDIC_MOVE_ATTACK_CABLE),
        _ => None,
    }
}
