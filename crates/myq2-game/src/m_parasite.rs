// m_parasite.rs â€” Parasite monster
// Converted from: myq2-original/game/m_parasite.c
// Frame definitions from: myq2-original/game/m_parasite.h

use crate::g_local::*;
use crate::game::*;
use crate::entity_adapters::{
    gi_sound, gi_soundindex, gi_modelindex, gi_linkentity,
    throw_gib, throw_head, g_free_edict, walkmonster_start,
};
use crate::game_import::{skill_value, gi_write_byte, gi_write_short, gi_write_position, gi_multicast};
use myq2_common::common::frand as random;
use myq2_common::q_shared::vector_length;

// ============================================================
// Frame definitions (from m_parasite.h)
// This file generated by ModelGen - Do NOT Modify
// ============================================================

pub const FRAME_BREAK01: i32 = 0;
pub const FRAME_BREAK02: i32 = 1;
pub const FRAME_BREAK03: i32 = 2;
pub const FRAME_BREAK04: i32 = 3;
pub const FRAME_BREAK05: i32 = 4;
pub const FRAME_BREAK06: i32 = 5;
pub const FRAME_BREAK07: i32 = 6;
pub const FRAME_BREAK08: i32 = 7;
pub const FRAME_BREAK09: i32 = 8;
pub const FRAME_BREAK10: i32 = 9;
pub const FRAME_BREAK11: i32 = 10;
pub const FRAME_BREAK12: i32 = 11;
pub const FRAME_BREAK13: i32 = 12;
pub const FRAME_BREAK14: i32 = 13;
pub const FRAME_BREAK15: i32 = 14;
pub const FRAME_BREAK16: i32 = 15;
pub const FRAME_BREAK17: i32 = 16;
pub const FRAME_BREAK18: i32 = 17;
pub const FRAME_BREAK19: i32 = 18;
pub const FRAME_BREAK20: i32 = 19;
pub const FRAME_BREAK21: i32 = 20;
pub const FRAME_BREAK22: i32 = 21;
pub const FRAME_BREAK23: i32 = 22;
pub const FRAME_BREAK24: i32 = 23;
pub const FRAME_BREAK25: i32 = 24;
pub const FRAME_BREAK26: i32 = 25;
pub const FRAME_BREAK27: i32 = 26;
pub const FRAME_BREAK28: i32 = 27;
pub const FRAME_BREAK29: i32 = 28;
pub const FRAME_BREAK30: i32 = 29;
pub const FRAME_BREAK31: i32 = 30;
pub const FRAME_BREAK32: i32 = 31;
pub const FRAME_DEATH101: i32 = 32;
pub const FRAME_DEATH102: i32 = 33;
pub const FRAME_DEATH103: i32 = 34;
pub const FRAME_DEATH104: i32 = 35;
pub const FRAME_DEATH105: i32 = 36;
pub const FRAME_DEATH106: i32 = 37;
pub const FRAME_DEATH107: i32 = 38;
pub const FRAME_DRAIN01: i32 = 39;
pub const FRAME_DRAIN02: i32 = 40;
pub const FRAME_DRAIN03: i32 = 41;
pub const FRAME_DRAIN04: i32 = 42;
pub const FRAME_DRAIN05: i32 = 43;
pub const FRAME_DRAIN06: i32 = 44;
pub const FRAME_DRAIN07: i32 = 45;
pub const FRAME_DRAIN08: i32 = 46;
pub const FRAME_DRAIN09: i32 = 47;
pub const FRAME_DRAIN10: i32 = 48;
pub const FRAME_DRAIN11: i32 = 49;
pub const FRAME_DRAIN12: i32 = 50;
pub const FRAME_DRAIN13: i32 = 51;
pub const FRAME_DRAIN14: i32 = 52;
pub const FRAME_DRAIN15: i32 = 53;
pub const FRAME_DRAIN16: i32 = 54;
pub const FRAME_DRAIN17: i32 = 55;
pub const FRAME_DRAIN18: i32 = 56;
pub const FRAME_PAIN101: i32 = 57;
pub const FRAME_PAIN102: i32 = 58;
pub const FRAME_PAIN103: i32 = 59;
pub const FRAME_PAIN104: i32 = 60;
pub const FRAME_PAIN105: i32 = 61;
pub const FRAME_PAIN106: i32 = 62;
pub const FRAME_PAIN107: i32 = 63;
pub const FRAME_PAIN108: i32 = 64;
pub const FRAME_PAIN109: i32 = 65;
pub const FRAME_PAIN110: i32 = 66;
pub const FRAME_PAIN111: i32 = 67;
pub const FRAME_RUN01: i32 = 68;
pub const FRAME_RUN02: i32 = 69;
pub const FRAME_RUN03: i32 = 70;
pub const FRAME_RUN04: i32 = 71;
pub const FRAME_RUN05: i32 = 72;
pub const FRAME_RUN06: i32 = 73;
pub const FRAME_RUN07: i32 = 74;
pub const FRAME_RUN08: i32 = 75;
pub const FRAME_RUN09: i32 = 76;
pub const FRAME_RUN10: i32 = 77;
pub const FRAME_RUN11: i32 = 78;
pub const FRAME_RUN12: i32 = 79;
pub const FRAME_RUN13: i32 = 80;
pub const FRAME_RUN14: i32 = 81;
pub const FRAME_RUN15: i32 = 82;
pub const FRAME_STAND01: i32 = 83;
pub const FRAME_STAND02: i32 = 84;
pub const FRAME_STAND03: i32 = 85;
pub const FRAME_STAND04: i32 = 86;
pub const FRAME_STAND05: i32 = 87;
pub const FRAME_STAND06: i32 = 88;
pub const FRAME_STAND07: i32 = 89;
pub const FRAME_STAND08: i32 = 90;
pub const FRAME_STAND09: i32 = 91;
pub const FRAME_STAND10: i32 = 92;
pub const FRAME_STAND11: i32 = 93;
pub const FRAME_STAND12: i32 = 94;
pub const FRAME_STAND13: i32 = 95;
pub const FRAME_STAND14: i32 = 96;
pub const FRAME_STAND15: i32 = 97;
pub const FRAME_STAND16: i32 = 98;
pub const FRAME_STAND17: i32 = 99;
pub const FRAME_STAND18: i32 = 100;
pub const FRAME_STAND19: i32 = 101;
pub const FRAME_STAND20: i32 = 102;
pub const FRAME_STAND21: i32 = 103;
pub const FRAME_STAND22: i32 = 104;
pub const FRAME_STAND23: i32 = 105;
pub const FRAME_STAND24: i32 = 106;
pub const FRAME_STAND25: i32 = 107;
pub const FRAME_STAND26: i32 = 108;
pub const FRAME_STAND27: i32 = 109;
pub const FRAME_STAND28: i32 = 110;
pub const FRAME_STAND29: i32 = 111;
pub const FRAME_STAND30: i32 = 112;
pub const FRAME_STAND31: i32 = 113;
pub const FRAME_STAND32: i32 = 114;
pub const FRAME_STAND33: i32 = 115;
pub const FRAME_STAND34: i32 = 116;
pub const FRAME_STAND35: i32 = 117;

pub const MODEL_SCALE: f32 = 1.0;

// ============================================================
// Sound channel / attenuation constants (mirrors C defines)
// ============================================================

// CHAN_*, ATTN_* come from g_local::* re-export (myq2_common::q_shared)

// ============================================================

use crate::ai_wrappers::{ai_stand, ai_walk, ai_run, ai_charge, ai_move};

// ============================================================
// Sound indices (module-level state, replaces C statics)
// ============================================================

#[derive(Default)]
pub struct ParasiteSounds {
    pub pain1: i32,
    pub pain2: i32,
    pub die: i32,
    pub launch: i32,
    pub impact: i32,
    pub suck: i32,
    pub reelin: i32,
    pub sight: i32,
    pub tap: i32,
    pub scratch: i32,
    pub search: i32,
}

static SOUNDS: std::sync::OnceLock<ParasiteSounds> = std::sync::OnceLock::new();


use myq2_common::q_shared::angle_vectors;


use crate::g_utils::vectoangles;



// ============================================================
// Move indices
// ============================================================

pub const MOVE_STAND: usize = 0;
pub const MOVE_START_FIDGET: usize = 1;
pub const MOVE_FIDGET: usize = 2;
pub const MOVE_END_FIDGET: usize = 3;
pub const MOVE_RUN: usize = 4;
pub const MOVE_START_RUN: usize = 5;
pub const MOVE_STOP_RUN: usize = 6;
pub const MOVE_WALK: usize = 7;
pub const MOVE_START_WALK: usize = 8;
pub const MOVE_STOP_WALK: usize = 9;
pub const MOVE_PAIN1: usize = 10;
pub const MOVE_DRAIN: usize = 11;
pub const MOVE_BREAK: usize = 12;
pub const MOVE_DEATH: usize = 13;

// ============================================================
// Parasite behavior functions
// ============================================================

pub fn parasite_launch(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_launch = SOUNDS.get().map_or(0, |s| s.launch);
    gi_sound(self_ent, CHAN_WEAPON, sound_launch, 1.0, ATTN_NORM, 0.0);
}

pub fn parasite_reel_in(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_reelin = SOUNDS.get().map_or(0, |s| s.reelin);
    gi_sound(self_ent, CHAN_WEAPON, sound_reelin, 1.0, ATTN_NORM, 0.0);
}

pub fn parasite_sight(self_ent: &mut Edict, _other: &mut Edict) {
    let sound_sight = SOUNDS.get().map_or(0, |s| s.sight);
    gi_sound(self_ent, CHAN_WEAPON, sound_sight, 1.0, ATTN_NORM, 0.0);
}

pub fn parasite_tap(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_tap = SOUNDS.get().map_or(0, |s| s.tap);
    gi_sound(self_ent, CHAN_WEAPON, sound_tap, 1.0, ATTN_IDLE, 0.0);
}

pub fn parasite_scratch(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_scratch = SOUNDS.get().map_or(0, |s| s.scratch);
    gi_sound(self_ent, CHAN_WEAPON, sound_scratch, 1.0, ATTN_IDLE, 0.0);
}

pub fn parasite_search(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_search = SOUNDS.get().map_or(0, |s| s.search);
    gi_sound(self_ent, CHAN_WEAPON, sound_search, 1.0, ATTN_IDLE, 0.0);
}

// ============================================================
// Fidget animations
// ============================================================

static PARASITE_FRAMES_START_FIDGET: [MFrame; 4] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static PARASITE_MOVE_START_FIDGET: MMove = MMove {
    firstframe: FRAME_STAND18,
    lastframe: FRAME_STAND21,
    frames: &PARASITE_FRAMES_START_FIDGET,
    endfunc: Some(parasite_do_fidget),
};

static PARASITE_FRAMES_FIDGET: [MFrame; 6] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(parasite_scratch) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(parasite_scratch) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static PARASITE_MOVE_FIDGET: MMove = MMove {
    firstframe: FRAME_STAND22,
    lastframe: FRAME_STAND27,
    frames: &PARASITE_FRAMES_FIDGET,
    endfunc: Some(parasite_refidget),
};

static PARASITE_FRAMES_END_FIDGET: [MFrame; 8] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(parasite_scratch) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static PARASITE_MOVE_END_FIDGET: MMove = MMove {
    firstframe: FRAME_STAND28,
    lastframe: FRAME_STAND35,
    frames: &PARASITE_FRAMES_END_FIDGET,
    endfunc: Some(parasite_stand),
};

pub fn parasite_end_fidget(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_END_FIDGET);
}

pub fn parasite_do_fidget(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_FIDGET);
}

pub fn parasite_refidget(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if random() <= 0.8 {
        self_ent.monsterinfo.currentmove = Some(MOVE_FIDGET);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_END_FIDGET);
    }
}

pub fn parasite_idle(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_START_FIDGET);
}

// ============================================================
// Stand animation
// ============================================================

static PARASITE_FRAMES_STAND: [MFrame; 17] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(parasite_tap) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(parasite_tap) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(parasite_tap) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(parasite_tap) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(parasite_tap) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(parasite_tap) },
];

pub static PARASITE_MOVE_STAND: MMove = MMove {
    firstframe: FRAME_STAND01,
    lastframe: FRAME_STAND17,
    frames: &PARASITE_FRAMES_STAND,
    endfunc: Some(parasite_stand),
};

pub fn parasite_stand(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
}

// ============================================================
// Run animation
// ============================================================

static PARASITE_FRAMES_RUN: [MFrame; 7] = [
    MFrame { ai_fn: ai_run, dist: 30.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 30.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 22.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 19.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 24.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 28.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 25.0, think_fn: None },
];

pub static PARASITE_MOVE_RUN: MMove = MMove {
    firstframe: FRAME_RUN03,
    lastframe: FRAME_RUN09,
    frames: &PARASITE_FRAMES_RUN,
    endfunc: None,
};

static PARASITE_FRAMES_START_RUN: [MFrame; 2] = [
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 30.0, think_fn: None },
];

pub static PARASITE_MOVE_START_RUN: MMove = MMove {
    firstframe: FRAME_RUN01,
    lastframe: FRAME_RUN02,
    frames: &PARASITE_FRAMES_START_RUN,
    endfunc: Some(parasite_run),
};

static PARASITE_FRAMES_STOP_RUN: [MFrame; 6] = [
    MFrame { ai_fn: ai_run, dist: 20.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 20.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 12.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
];

pub static PARASITE_MOVE_STOP_RUN: MMove = MMove {
    firstframe: FRAME_RUN10,
    lastframe: FRAME_RUN15,
    frames: &PARASITE_FRAMES_STOP_RUN,
    endfunc: None,
};

pub fn parasite_start_run(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_START_RUN);
    }
}

pub fn parasite_run(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_RUN);
    }
}

// ============================================================
// Walk animation
// ============================================================

static PARASITE_FRAMES_WALK: [MFrame; 7] = [
    MFrame { ai_fn: ai_walk, dist: 30.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 30.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 22.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 19.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 24.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 28.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 25.0, think_fn: None },
];

pub static PARASITE_MOVE_WALK: MMove = MMove {
    firstframe: FRAME_RUN03,
    lastframe: FRAME_RUN09,
    frames: &PARASITE_FRAMES_WALK,
    endfunc: Some(parasite_walk),
};

static PARASITE_FRAMES_START_WALK: [MFrame; 2] = [
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 30.0, think_fn: Some(parasite_walk) },
];

pub static PARASITE_MOVE_START_WALK: MMove = MMove {
    firstframe: FRAME_RUN01,
    lastframe: FRAME_RUN02,
    frames: &PARASITE_FRAMES_START_WALK,
    endfunc: None,
};

static PARASITE_FRAMES_STOP_WALK: [MFrame; 6] = [
    MFrame { ai_fn: ai_walk, dist: 20.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 20.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 12.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
];

pub static PARASITE_MOVE_STOP_WALK: MMove = MMove {
    firstframe: FRAME_RUN10,
    lastframe: FRAME_RUN15,
    frames: &PARASITE_FRAMES_STOP_WALK,
    endfunc: None,
};

pub fn parasite_start_walk(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_START_WALK);
}

pub fn parasite_walk(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_WALK);
}

// ============================================================
// Pain animation
// ============================================================

static PARASITE_FRAMES_PAIN1: [MFrame; 11] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 16.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -6.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -7.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static PARASITE_MOVE_PAIN1: MMove = MMove {
    firstframe: FRAME_PAIN101,
    lastframe: FRAME_PAIN111,
    frames: &PARASITE_FRAMES_PAIN1,
    endfunc: Some(parasite_start_run),
};

pub fn parasite_pain(self_ent: &mut Edict, _other: &mut Edict, _kick: f32, _damage: i32, ctx: &mut GameContext) {
    if self_ent.health < (self_ent.max_health / 2) {
        self_ent.s.skinnum = 1;
    }

    if ctx.level.time < self_ent.pain_debounce_time {
        return;
    }

    self_ent.pain_debounce_time = ctx.level.time + 3.0;

    // skill->value == 3 means nightmare: no pain anims
    if skill_value() == 3.0 {
        return; // no pain anims in nightmare
    }

    if random() < 0.5 {
        let sound_pain1 = SOUNDS.get().map_or(0, |s| s.pain1);
        gi_sound(self_ent, CHAN_VOICE, sound_pain1, 1.0, ATTN_NORM, 0.0);
    } else {
        let sound_pain2 = SOUNDS.get().map_or(0, |s| s.pain2);
        gi_sound(self_ent, CHAN_VOICE, sound_pain2, 1.0, ATTN_NORM, 0.0);
    }

    self_ent.monsterinfo.currentmove = Some(MOVE_PAIN1);
}

// ============================================================
// Drain attack
// ============================================================

/// Check if drain attack geometry is valid (distance and pitch constraints).
fn parasite_drain_attack_ok(start: [f32; 3], end: [f32; 3]) -> bool {
    let dir = [
        start[0] - end[0],
        start[1] - end[1],
        start[2] - end[2],
    ];

    // check for max distance
    if vector_length(&dir) > 256.0 {
        return false;
    }

    // check for min/max pitch
    let mut angles = [0.0_f32; 3];
    vectoangles(&dir, &mut angles);
    if angles[0] < -180.0 {
        angles[0] += 360.0;
    }
    if angles[0].abs() > 30.0 {
        return false;
    }

    true
}

/// Performs the parasite drain attack each frame it is active.
/// In the C code this accesses self->enemy directly; here we use entity indices
/// and placeholder accessors until the full entity system is wired.
pub fn parasite_drain_attack(self_ent: &mut Edict, ctx: &mut GameContext) {
    let self_idx: usize = self_ent.s.number as usize;
    let mut f = [0.0_f32; 3];
    let mut r = [0.0_f32; 3];
    angle_vectors(&self_ent.s.angles, Some(&mut f), Some(&mut r), None);

    let offset = [24.0_f32, 0.0, 6.0];
    let mut start = [0.0_f32; 3];
    crate::entity_adapters::g_project_source(&self_ent.s.origin, &offset, &f, &r, &mut start);

    let enemy_index = self_ent.enemy;
    if enemy_index < 0 {
        return;
    }
    let enemy = &ctx.edicts[enemy_index as usize];
    let enemy_origin = enemy.s.origin;
    let enemy_maxs = enemy.maxs;
    let enemy_mins = enemy.mins;

    let mut end = enemy_origin;

    if !parasite_drain_attack_ok(start, end) {
        end[2] = enemy_origin[2] + enemy_maxs[2] - 8.0;
        if !parasite_drain_attack_ok(start, end) {
            end[2] = enemy_origin[2] + enemy_mins[2] + 8.0;
            if !parasite_drain_attack_ok(start, end) {
                return;
            }
        }
    }
    // Reset end to enemy origin for trace
    end = enemy_origin;

    let tr = crate::game_import::gi_trace(&start, &[0.0; 3], &[0.0; 3], &end, self_idx as i32, MASK_SHOT);
    if tr.ent_index != enemy_index {
        return;
    }

    let damage;
    if self_ent.s.frame == FRAME_DRAIN03 {
        damage = 5;
        let sound_impact = SOUNDS.get().map_or(0, |s| s.impact);
        // gi.sound(self->enemy, CHAN_AUTO, sound_impact, 1, ATTN_NORM, 0)
        crate::game_import::gi_sound(enemy_index, CHAN_AUTO, sound_impact, 1.0, ATTN_NORM, 0.0);
    } else {
        if self_ent.s.frame == FRAME_DRAIN04 {
            let sound_suck = SOUNDS.get().map_or(0, |s| s.suck);
            gi_sound(self_ent, CHAN_WEAPON, sound_suck, 1.0, ATTN_NORM, 0.0);
        }
        damage = 2;
    }

    // Write temp entity message
    gi_write_byte(SVC_TEMP_ENTITY);
    gi_write_byte(TE_PARASITE_ATTACK);
    gi_write_short(self_idx as i32);
    gi_write_position(&start);
    gi_write_position(&end);
    gi_multicast(&self_ent.s.origin, MULTICAST_PVS);

    let dir = [
        start[0] - end[0],
        start[1] - end[1],
        start[2] - end[2],
    ];
    let targ_idx = self_ent.s.number as usize;
    crate::g_local::with_global_game_ctx(|ctx| {
        crate::g_combat::ctx_t_damage(
            ctx, targ_idx, self_idx, self_idx,
            &dir, &enemy_origin, &[0.0, 0.0, 0.0],
            damage, 0, DAMAGE_NO_KNOCKBACK, MOD_UNKNOWN,
        );
    });
}

// ============================================================
// Drain animation
// ============================================================

static PARASITE_FRAMES_DRAIN: [MFrame; 18] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(parasite_launch) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 15.0, think_fn: Some(parasite_drain_attack) },  // Target hits
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(parasite_drain_attack) },   // drain
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(parasite_drain_attack) },   // drain
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(parasite_drain_attack) },   // drain
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(parasite_drain_attack) },   // drain
    MFrame { ai_fn: ai_charge, dist: -2.0, think_fn: Some(parasite_drain_attack) },  // drain
    MFrame { ai_fn: ai_charge, dist: -2.0, think_fn: Some(parasite_drain_attack) },  // drain
    MFrame { ai_fn: ai_charge, dist: -3.0, think_fn: Some(parasite_drain_attack) },  // drain
    MFrame { ai_fn: ai_charge, dist: -2.0, think_fn: Some(parasite_drain_attack) },  // drain
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(parasite_drain_attack) },   // drain
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: Some(parasite_drain_attack) },  // drain
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(parasite_reel_in) },        // let go
    MFrame { ai_fn: ai_charge, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
];

pub static PARASITE_MOVE_DRAIN: MMove = MMove {
    firstframe: FRAME_DRAIN01,
    lastframe: FRAME_DRAIN18,
    frames: &PARASITE_FRAMES_DRAIN,
    endfunc: Some(parasite_start_run),
};

// ============================================================
// Break animation
// ============================================================

static PARASITE_FRAMES_BREAK: [MFrame; 32] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -18.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 9.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -18.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 9.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -18.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },   // airborne
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },   // airborne
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },   // slides
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },   // slides
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },   // slides
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },   // slides
    MFrame { ai_fn: ai_charge, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 11.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -5.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
];

pub static PARASITE_MOVE_BREAK: MMove = MMove {
    firstframe: FRAME_BREAK01,
    lastframe: FRAME_BREAK32,
    frames: &PARASITE_FRAMES_BREAK,
    endfunc: Some(parasite_start_run),
};

// ============================================================
// Attack
// ============================================================

pub fn parasite_attack(self_ent: &mut Edict, _ctx: &mut GameContext) {
    // In the C code, the break attack is commented out:
    //   if (random() <= 0.2)
    //       self->monsterinfo.currentmove = &parasite_move_break;
    //   else
    self_ent.monsterinfo.currentmove = Some(MOVE_DRAIN);
}

// ============================================================
// Death
// ============================================================

fn parasite_dead(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.mins = [-16.0, -16.0, -24.0];
    self_ent.maxs = [16.0, 16.0, -8.0];
    self_ent.movetype = MoveType::Toss;
    self_ent.svflags |= SVF_DEADMONSTER;
    self_ent.nextthink = 0.0;
    gi_linkentity(self_ent);
}

static PARASITE_FRAMES_DEATH: [MFrame; 7] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static PARASITE_MOVE_DEATH: MMove = MMove {
    firstframe: FRAME_DEATH101,
    lastframe: FRAME_DEATH107,
    frames: &PARASITE_FRAMES_DEATH,
    endfunc: Some(parasite_dead),
};

pub fn parasite_die(self_ent: &mut Edict, _inflictor: &mut Edict, _attacker: &mut Edict, damage: i32, _point: [f32; 3], _ctx: &mut GameContext) {
    // check for gib
    if self_ent.health <= self_ent.gib_health {
        gi_sound(self_ent, CHAN_VOICE, gi_soundindex("misc/udeath.wav"), 1.0, ATTN_NORM, 0.0);
        for _ in 0..2 {
            throw_gib(self_ent, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
        }
        for _ in 0..4 {
            throw_gib(self_ent, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
        }
        throw_head(self_ent, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
        self_ent.deadflag = DEAD_DEAD;
        return;
    }

    if self_ent.deadflag == DEAD_DEAD {
        return;
    }

    // regular death
    let sound_die = SOUNDS.get().map_or(0, |s| s.die);
    gi_sound(self_ent, CHAN_VOICE, sound_die, 1.0, ATTN_NORM, 0.0);
    self_ent.deadflag = DEAD_DEAD;
    self_ent.takedamage = Damage::Yes as i32;
    self_ent.monsterinfo.currentmove = Some(MOVE_DEATH);
}

// ============================================================
// Spawn function
// ============================================================

/// QUAKED monster_parasite (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
pub fn sp_monster_parasite(self_ent: &mut Edict, ctx: &mut GameContext) {
    if ctx.deathmatch != 0.0 {
        g_free_edict(self_ent);
        return;
    }

    // Pre-caches
    SOUNDS.get_or_init(|| ParasiteSounds {
        pain1: gi_soundindex("parasite/parpain1.wav"),
        pain2: gi_soundindex("parasite/parpain2.wav"),
        die: gi_soundindex("parasite/pardeth1.wav"),
        launch: gi_soundindex("parasite/paratck1.wav"),
        impact: gi_soundindex("parasite/paratck2.wav"),
        suck: gi_soundindex("parasite/paratck3.wav"),
        reelin: gi_soundindex("parasite/paratck4.wav"),
        sight: gi_soundindex("parasite/parsght1.wav"),
        tap: gi_soundindex("parasite/paridle1.wav"),
        scratch: gi_soundindex("parasite/paridle2.wav"),
        search: gi_soundindex("parasite/parsrch1.wav"),
    });

    self_ent.s.modelindex = gi_modelindex("models/monsters/parasite/tris.md2");
    self_ent.mins = [-16.0, -16.0, -24.0];
    self_ent.maxs = [16.0, 16.0, 24.0];
    self_ent.movetype = MoveType::Step;
    self_ent.solid = Solid::Bbox;

    self_ent.health = 175;
    self_ent.gib_health = -50;
    self_ent.mass = 250;

    self_ent.pain_fn = Some(crate::dispatch::PAIN_PARASITE);
    self_ent.die_fn = Some(crate::dispatch::DIE_PARASITE);

    self_ent.monsterinfo.stand_fn = Some(crate::dispatch::MSTAND_PARASITE);
    self_ent.monsterinfo.walk_fn = Some(crate::dispatch::MWALK_PARASITE);
    self_ent.monsterinfo.run_fn = Some(crate::dispatch::MRUN_PARASITE);
    self_ent.monsterinfo.attack_fn = Some(crate::dispatch::MATTACK_PARASITE);
    self_ent.monsterinfo.sight_fn = Some(crate::dispatch::MSIGHT_PARASITE);
    self_ent.monsterinfo.idle_fn = Some(crate::dispatch::MIDLE_PARASITE);

    gi_linkentity(self_ent);

    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    self_ent.monsterinfo.scale = MODEL_SCALE;

    walkmonster_start(self_ent);
}

// ============================================================
// Move table: maps move indices to MMove statics
// ============================================================

/// Returns the MMove for a given parasite move index.
pub fn parasite_get_move(index: usize) -> Option<&'static MMove> {
    match index {
        MOVE_STAND => Some(&PARASITE_MOVE_STAND),
        MOVE_START_FIDGET => Some(&PARASITE_MOVE_START_FIDGET),
        MOVE_FIDGET => Some(&PARASITE_MOVE_FIDGET),
        MOVE_END_FIDGET => Some(&PARASITE_MOVE_END_FIDGET),
        MOVE_RUN => Some(&PARASITE_MOVE_RUN),
        MOVE_START_RUN => Some(&PARASITE_MOVE_START_RUN),
        MOVE_STOP_RUN => Some(&PARASITE_MOVE_STOP_RUN),
        MOVE_WALK => Some(&PARASITE_MOVE_WALK),
        MOVE_START_WALK => Some(&PARASITE_MOVE_START_WALK),
        MOVE_STOP_WALK => Some(&PARASITE_MOVE_STOP_WALK),
        MOVE_PAIN1 => Some(&PARASITE_MOVE_PAIN1),
        MOVE_DRAIN => Some(&PARASITE_MOVE_DRAIN),
        MOVE_BREAK => Some(&PARASITE_MOVE_BREAK),
        MOVE_DEATH => Some(&PARASITE_MOVE_DEATH),
        _ => None,
    }
}
