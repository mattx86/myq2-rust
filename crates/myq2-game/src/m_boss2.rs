// m_boss2.rs — Boss2 (Hornet) monster
// Converted from: myq2-original/game/m_boss2.c
// Frame definitions from: myq2-original/game/m_boss2.h

use crate::g_local::*;
use crate::game::*;
use crate::entity_adapters::{gi_sound, gi_soundindex, gi_modelindex, gi_linkentity, g_free_edict, throw_gib, throw_head, flymonster_start, monster_flash_offset, g_project_source, monster_fire_rocket, monster_fire_bullet};
use myq2_common::common::frand as random;
use myq2_common::q_shared::{vector_normalize, vector_length};

// ============================================================
// Frame definitions (from m_boss2.h)
// This file generated by ModelGen - Do NOT Modify
// ============================================================

pub const FRAME_STAND30: i32 = 0;
pub const FRAME_STAND31: i32 = 1;
pub const FRAME_STAND32: i32 = 2;
pub const FRAME_STAND33: i32 = 3;
pub const FRAME_STAND34: i32 = 4;
pub const FRAME_STAND35: i32 = 5;
pub const FRAME_STAND36: i32 = 6;
pub const FRAME_STAND37: i32 = 7;
pub const FRAME_STAND38: i32 = 8;
pub const FRAME_STAND39: i32 = 9;
pub const FRAME_STAND40: i32 = 10;
pub const FRAME_STAND41: i32 = 11;
pub const FRAME_STAND42: i32 = 12;
pub const FRAME_STAND43: i32 = 13;
pub const FRAME_STAND44: i32 = 14;
pub const FRAME_STAND45: i32 = 15;
pub const FRAME_STAND46: i32 = 16;
pub const FRAME_STAND47: i32 = 17;
pub const FRAME_STAND48: i32 = 18;
pub const FRAME_STAND49: i32 = 19;
pub const FRAME_STAND50: i32 = 20;
pub const FRAME_STAND1: i32 = 21;
pub const FRAME_STAND2: i32 = 22;
pub const FRAME_STAND3: i32 = 23;
pub const FRAME_STAND4: i32 = 24;
pub const FRAME_STAND5: i32 = 25;
pub const FRAME_STAND6: i32 = 26;
pub const FRAME_STAND7: i32 = 27;
pub const FRAME_STAND8: i32 = 28;
pub const FRAME_STAND9: i32 = 29;
pub const FRAME_STAND10: i32 = 30;
pub const FRAME_STAND11: i32 = 31;
pub const FRAME_STAND12: i32 = 32;
pub const FRAME_STAND13: i32 = 33;
pub const FRAME_STAND14: i32 = 34;
pub const FRAME_STAND15: i32 = 35;
pub const FRAME_STAND16: i32 = 36;
pub const FRAME_STAND17: i32 = 37;
pub const FRAME_STAND18: i32 = 38;
pub const FRAME_STAND19: i32 = 39;
pub const FRAME_STAND20: i32 = 40;
pub const FRAME_STAND21: i32 = 41;
pub const FRAME_STAND22: i32 = 42;
pub const FRAME_STAND23: i32 = 43;
pub const FRAME_STAND24: i32 = 44;
pub const FRAME_STAND25: i32 = 45;
pub const FRAME_STAND26: i32 = 46;
pub const FRAME_STAND27: i32 = 47;
pub const FRAME_STAND28: i32 = 48;
pub const FRAME_STAND29: i32 = 49;
pub const FRAME_WALK1: i32 = 50;
pub const FRAME_WALK2: i32 = 51;
pub const FRAME_WALK3: i32 = 52;
pub const FRAME_WALK4: i32 = 53;
pub const FRAME_WALK5: i32 = 54;
pub const FRAME_WALK6: i32 = 55;
pub const FRAME_WALK7: i32 = 56;
pub const FRAME_WALK8: i32 = 57;
pub const FRAME_WALK9: i32 = 58;
pub const FRAME_WALK10: i32 = 59;
pub const FRAME_WALK11: i32 = 60;
pub const FRAME_WALK12: i32 = 61;
pub const FRAME_WALK13: i32 = 62;
pub const FRAME_WALK14: i32 = 63;
pub const FRAME_WALK15: i32 = 64;
pub const FRAME_WALK16: i32 = 65;
pub const FRAME_WALK17: i32 = 66;
pub const FRAME_WALK18: i32 = 67;
pub const FRAME_WALK19: i32 = 68;
pub const FRAME_WALK20: i32 = 69;
pub const FRAME_ATTACK1: i32 = 70;
pub const FRAME_ATTACK2: i32 = 71;
pub const FRAME_ATTACK3: i32 = 72;
pub const FRAME_ATTACK4: i32 = 73;
pub const FRAME_ATTACK5: i32 = 74;
pub const FRAME_ATTACK6: i32 = 75;
pub const FRAME_ATTACK7: i32 = 76;
pub const FRAME_ATTACK8: i32 = 77;
pub const FRAME_ATTACK9: i32 = 78;
pub const FRAME_ATTACK10: i32 = 79;
pub const FRAME_ATTACK11: i32 = 80;
pub const FRAME_ATTACK12: i32 = 81;
pub const FRAME_ATTACK13: i32 = 82;
pub const FRAME_ATTACK14: i32 = 83;
pub const FRAME_ATTACK15: i32 = 84;
pub const FRAME_ATTACK16: i32 = 85;
pub const FRAME_ATTACK17: i32 = 86;
pub const FRAME_ATTACK18: i32 = 87;
pub const FRAME_ATTACK19: i32 = 88;
pub const FRAME_ATTACK20: i32 = 89;
pub const FRAME_ATTACK21: i32 = 90;
pub const FRAME_ATTACK22: i32 = 91;
pub const FRAME_ATTACK23: i32 = 92;
pub const FRAME_ATTACK24: i32 = 93;
pub const FRAME_ATTACK25: i32 = 94;
pub const FRAME_ATTACK26: i32 = 95;
pub const FRAME_ATTACK27: i32 = 96;
pub const FRAME_ATTACK28: i32 = 97;
pub const FRAME_ATTACK29: i32 = 98;
pub const FRAME_ATTACK30: i32 = 99;
pub const FRAME_ATTACK31: i32 = 100;
pub const FRAME_ATTACK32: i32 = 101;
pub const FRAME_ATTACK33: i32 = 102;
pub const FRAME_ATTACK34: i32 = 103;
pub const FRAME_ATTACK35: i32 = 104;
pub const FRAME_ATTACK36: i32 = 105;
pub const FRAME_ATTACK37: i32 = 106;
pub const FRAME_ATTACK38: i32 = 107;
pub const FRAME_ATTACK39: i32 = 108;
pub const FRAME_ATTACK40: i32 = 109;
pub const FRAME_PAIN2: i32 = 110;
pub const FRAME_PAIN3: i32 = 111;
pub const FRAME_PAIN4: i32 = 112;
pub const FRAME_PAIN5: i32 = 113;
pub const FRAME_PAIN6: i32 = 114;
pub const FRAME_PAIN7: i32 = 115;
pub const FRAME_PAIN8: i32 = 116;
pub const FRAME_PAIN9: i32 = 117;
pub const FRAME_PAIN10: i32 = 118;
pub const FRAME_PAIN11: i32 = 119;
pub const FRAME_PAIN12: i32 = 120;
pub const FRAME_PAIN13: i32 = 121;
pub const FRAME_PAIN14: i32 = 122;
pub const FRAME_PAIN15: i32 = 123;
pub const FRAME_PAIN16: i32 = 124;
pub const FRAME_PAIN17: i32 = 125;
pub const FRAME_PAIN18: i32 = 126;
pub const FRAME_PAIN19: i32 = 127;
pub const FRAME_PAIN20: i32 = 128;
pub const FRAME_PAIN21: i32 = 129;
pub const FRAME_PAIN22: i32 = 130;
pub const FRAME_PAIN23: i32 = 131;
pub const FRAME_DEATH2: i32 = 132;
pub const FRAME_DEATH3: i32 = 133;
pub const FRAME_DEATH4: i32 = 134;
pub const FRAME_DEATH5: i32 = 135;
pub const FRAME_DEATH6: i32 = 136;
pub const FRAME_DEATH7: i32 = 137;
pub const FRAME_DEATH8: i32 = 138;
pub const FRAME_DEATH9: i32 = 139;
pub const FRAME_DEATH10: i32 = 140;
pub const FRAME_DEATH11: i32 = 141;
pub const FRAME_DEATH12: i32 = 142;
pub const FRAME_DEATH13: i32 = 143;
pub const FRAME_DEATH14: i32 = 144;
pub const FRAME_DEATH15: i32 = 145;
pub const FRAME_DEATH16: i32 = 146;
pub const FRAME_DEATH17: i32 = 147;
pub const FRAME_DEATH18: i32 = 148;
pub const FRAME_DEATH19: i32 = 149;
pub const FRAME_DEATH20: i32 = 150;
pub const FRAME_DEATH21: i32 = 151;
pub const FRAME_DEATH22: i32 = 152;
pub const FRAME_DEATH23: i32 = 153;
pub const FRAME_DEATH24: i32 = 154;
pub const FRAME_DEATH25: i32 = 155;
pub const FRAME_DEATH26: i32 = 156;
pub const FRAME_DEATH27: i32 = 157;
pub const FRAME_DEATH28: i32 = 158;
pub const FRAME_DEATH29: i32 = 159;
pub const FRAME_DEATH30: i32 = 160;
pub const FRAME_DEATH31: i32 = 161;
pub const FRAME_DEATH32: i32 = 162;
pub const FRAME_DEATH33: i32 = 163;
pub const FRAME_DEATH34: i32 = 164;
pub const FRAME_DEATH35: i32 = 165;
pub const FRAME_DEATH36: i32 = 166;
pub const FRAME_DEATH37: i32 = 167;
pub const FRAME_DEATH38: i32 = 168;
pub const FRAME_DEATH39: i32 = 169;
pub const FRAME_DEATH40: i32 = 170;
pub const FRAME_DEATH41: i32 = 171;
pub const FRAME_DEATH42: i32 = 172;
pub const FRAME_DEATH43: i32 = 173;
pub const FRAME_DEATH44: i32 = 174;
pub const FRAME_DEATH45: i32 = 175;
pub const FRAME_DEATH46: i32 = 176;
pub const FRAME_DEATH47: i32 = 177;
pub const FRAME_DEATH48: i32 = 178;
pub const FRAME_DEATH49: i32 = 179;
pub const FRAME_DEATH50: i32 = 180;

pub const MODEL_SCALE: f32 = 1.0;

// ============================================================
// Sound / attenuation constants
// ============================================================

// CHAN_*, ATTN_* come from g_local::* re-export (myq2_common::q_shared)

// ============================================================
// Sound indices (module-level state, replaces C statics)
// ============================================================

#[derive(Default)]
pub struct Boss2Sounds {
    pub pain1: i32,
    pub pain2: i32,
    pub pain3: i32,
    pub death: i32,
    pub search1: i32,
}

static SOUNDS: std::sync::OnceLock<Boss2Sounds> = std::sync::OnceLock::new();

// ============================================================
// Move table indices for monsterinfo.currentmove
// ============================================================

pub const MOVE_STAND: usize = 0;
pub const MOVE_FIDGET: usize = 1;
pub const MOVE_WALK: usize = 2;
pub const MOVE_RUN: usize = 3;
pub const MOVE_ATTACK_PRE_MG: usize = 4;
pub const MOVE_ATTACK_MG: usize = 5;
pub const MOVE_ATTACK_POST_MG: usize = 6;
pub const MOVE_ATTACK_ROCKET: usize = 7;
pub const MOVE_PAIN_HEAVY: usize = 8;
pub const MOVE_PAIN_LIGHT: usize = 9;
pub const MOVE_DEATH: usize = 10;

fn boss_explode(self_ent: &mut Edict, _ctx: &mut GameContext) {
    use crate::game_import::{gi_write_byte, gi_write_position, gi_multicast};

    // BossExplode — spawns a sequence of explosions then gibs the entity.
    // self.count tracks which explosion step we are on (0..=8).
    let mut org = self_ent.s.origin;
    org[2] += 24.0 + (rand::random::<i32>() & 15) as f32;

    match self_ent.count {
        0 => { org[0] -= 24.0; org[1] -= 24.0; }
        1 => { org[0] += 24.0; org[1] += 24.0; }
        2 => { org[0] += 24.0; org[1] -= 24.0; }
        3 => { org[0] -= 24.0; org[1] += 24.0; }
        4 => { org[0] -= 48.0; org[1] -= 48.0; }
        5 => { org[0] += 48.0; org[1] += 48.0; }
        6 => { org[0] -= 48.0; org[1] += 48.0; }
        7 => { org[0] += 48.0; org[1] -= 48.0; }
        8 => {
            self_ent.s.sound = 0;
            for _ in 0..4 {
                throw_gib(self_ent, "models/objects/gibs/sm_meat/tris.md2", 500, GIB_ORGANIC);
            }
            for _ in 0..8 {
                throw_gib(self_ent, "models/objects/gibs/sm_metal/tris.md2", 500, GIB_METALLIC);
            }
            throw_gib(self_ent, "models/objects/gibs/chest/tris.md2", 500, GIB_ORGANIC);
            throw_head(self_ent, "models/objects/gibs/gear/tris.md2", 500, GIB_METALLIC);
            self_ent.deadflag = DEAD_DEAD;
            self_ent.count += 1;
            return;
        }
        _ => {
            self_ent.count += 1;
            return;
        }
    }
    self_ent.count += 1;

    gi_write_byte(SVC_TEMP_ENTITY);
    gi_write_byte(TE_EXPLOSION1);
    gi_write_position(&org);
    gi_multicast(&self_ent.s.origin, MULTICAST_PVS);

    self_ent.nextthink += 0.1;
}

use crate::g_ai::{infront, range};
use crate::g_utils::vectoyaw;


use myq2_common::q_shared::angle_vectors;

use myq2_common::q_shared::vector_subtract;

use crate::ai_wrappers::{ai_stand, ai_walk, ai_run, ai_charge, ai_move};


// Flash number constants
const MZ2_BOSS2_ROCKET_1: i32 = 78;
const MZ2_BOSS2_ROCKET_2: i32 = 79;
const MZ2_BOSS2_ROCKET_3: i32 = 80;
const MZ2_BOSS2_ROCKET_4: i32 = 81;
const MZ2_BOSS2_MACHINEGUN_R1: i32 = 73;
const MZ2_BOSS2_MACHINEGUN_L1: i32 = 74;

// DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD come from g_local::*

// ============================================================
// Boss2 behavior functions
// ============================================================

pub fn boss2_search(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if random() < 0.5 {
        let sound_search1 = SOUNDS.get().map_or(0, |s| s.search1);
        gi_sound(self_ent, CHAN_VOICE, sound_search1, 1.0, ATTN_NONE, 0.0);
    }
}

/// Boss2Rocket - fires 4 rockets at the enemy
pub fn boss2_rocket(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let mut forward = [0.0f32; 3];
    let mut right = [0.0f32; 3];
    let mut start = [0.0f32; 3];
    let mut dir: [f32; 3];
    let mut vec: [f32; 3];

    let enemy_idx = self_ent.enemy;
    let (enemy_origin, enemy_vh) = if enemy_idx >= 0 {
        let e = &_ctx.edicts[enemy_idx as usize];
        (e.s.origin, e.viewheight)
    } else {
        ([0.0; 3], 0)
    };

    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);

    // 1
    let offset1 = monster_flash_offset(MZ2_BOSS2_ROCKET_1);
    g_project_source(&self_ent.s.origin, &offset1, &forward, &right, &mut start);
    vec = enemy_origin;
    vec[2] += enemy_vh as f32;
    dir = vector_subtract(&vec, &start);
    vector_normalize(&mut dir);
    monster_fire_rocket(self_ent, start, dir, 50, 500, MZ2_BOSS2_ROCKET_1);

    // 2
    let offset2 = monster_flash_offset(MZ2_BOSS2_ROCKET_2);
    g_project_source(&self_ent.s.origin, &offset2, &forward, &right, &mut start);
    vec = enemy_origin;
    vec[2] += enemy_vh as f32;
    dir = vector_subtract(&vec, &start);
    vector_normalize(&mut dir);
    monster_fire_rocket(self_ent, start, dir, 50, 500, MZ2_BOSS2_ROCKET_2);

    // 3
    let offset3 = monster_flash_offset(MZ2_BOSS2_ROCKET_3);
    g_project_source(&self_ent.s.origin, &offset3, &forward, &right, &mut start);
    vec = enemy_origin;
    vec[2] += enemy_vh as f32;
    dir = vector_subtract(&vec, &start);
    vector_normalize(&mut dir);
    monster_fire_rocket(self_ent, start, dir, 50, 500, MZ2_BOSS2_ROCKET_3);

    // 4
    let offset4 = monster_flash_offset(MZ2_BOSS2_ROCKET_4);
    g_project_source(&self_ent.s.origin, &offset4, &forward, &right, &mut start);
    vec = enemy_origin;
    vec[2] += enemy_vh as f32;
    dir = vector_subtract(&vec, &start);
    vector_normalize(&mut dir);
    monster_fire_rocket(self_ent, start, dir, 50, 500, MZ2_BOSS2_ROCKET_4);
}

/// boss2_firebullet_right
pub fn boss2_firebullet_right(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let mut forward = [0.0f32; 3];
    let mut right = [0.0f32; 3];
    let mut start = [0.0f32; 3];

    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
    let offset = monster_flash_offset(MZ2_BOSS2_MACHINEGUN_R1);
    g_project_source(&self_ent.s.origin, &offset, &forward, &right, &mut start);

    // VectorMA(self->enemy->s.origin, -0.2, self->enemy->velocity, target)
    // target[2] += self->enemy->viewheight
    let enemy_idx = self_ent.enemy;
    let (enemy_origin, enemy_vel, enemy_vh) = if enemy_idx >= 0 {
        let e = &_ctx.edicts[enemy_idx as usize];
        (e.s.origin, e.velocity, e.viewheight)
    } else {
        ([0.0; 3], [0.0; 3], 0)
    };
    let mut target = [
        enemy_origin[0] + -0.2 * enemy_vel[0],
        enemy_origin[1] + -0.2 * enemy_vel[1],
        enemy_origin[2] + -0.2 * enemy_vel[2],
    ];
    target[2] += enemy_vh as f32;
    forward = vector_subtract(&target, &start);
    vector_normalize(&mut forward);

    monster_fire_bullet(self_ent, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_BOSS2_MACHINEGUN_R1);
}

/// boss2_firebullet_left
pub fn boss2_firebullet_left(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let mut forward = [0.0f32; 3];
    let mut right = [0.0f32; 3];
    let mut start = [0.0f32; 3];

    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
    let offset = monster_flash_offset(MZ2_BOSS2_MACHINEGUN_L1);
    g_project_source(&self_ent.s.origin, &offset, &forward, &right, &mut start);

    // VectorMA(self->enemy->s.origin, -0.2, self->enemy->velocity, target)
    // target[2] += self->enemy->viewheight
    let enemy_idx = self_ent.enemy;
    let (enemy_origin, enemy_vel, enemy_vh) = if enemy_idx >= 0 {
        let e = &_ctx.edicts[enemy_idx as usize];
        (e.s.origin, e.velocity, e.viewheight)
    } else {
        ([0.0; 3], [0.0; 3], 0)
    };
    let mut target = [
        enemy_origin[0] + -0.2 * enemy_vel[0],
        enemy_origin[1] + -0.2 * enemy_vel[1],
        enemy_origin[2] + -0.2 * enemy_vel[2],
    ];
    target[2] += enemy_vh as f32;
    forward = vector_subtract(&target, &start);
    vector_normalize(&mut forward);

    monster_fire_bullet(self_ent, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_BOSS2_MACHINEGUN_L1);
}

/// Boss2MachineGun - fires both left and right machineguns
pub fn boss2_machinegun(self_ent: &mut Edict, ctx: &mut GameContext) {
    boss2_firebullet_left(self_ent, ctx);
    boss2_firebullet_right(self_ent, ctx);
}

// ============================================================
// Stand animation (FRAME_stand30 .. FRAME_stand50) - 21 frames
// ============================================================

static BOSS2_FRAMES_STAND: [MFrame; 21] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static BOSS2_MOVE_STAND: MMove = MMove {
    firstframe: FRAME_STAND30,
    lastframe: FRAME_STAND50,
    frames: &BOSS2_FRAMES_STAND,
    endfunc: None,
};

// ============================================================
// Fidget animation (FRAME_stand1 .. FRAME_stand30) - 30 frames (stand1=21 .. stand29=49, but C uses stand1..stand30 = 30 frames)
// Note: C header has stand1=21..stand29=49 (29 frames), stand30=0
// C code: FRAME_stand1 to FRAME_stand30 = frames 21..49 + 0? No.
// Actually re-reading: FRAME_stand1=21, FRAME_stand30=49. So 30 frames: 21..49 but that's only 29.
// Wait: stand1=21..stand29=49 is 29 values. FRAME_stand30=0. So FRAME_stand1..FRAME_stand30 wraps.
// The C mmove uses FRAME_stand1(21) to FRAME_stand30(49) -- but FRAME_stand30 = 0 per the header!
// Re-checking header: FRAME_stand30=0, FRAME_stand1=21, ..., FRAME_stand29=49.
// C code: boss2_move_fidget = {FRAME_stand1, FRAME_stand30, ...}
// FRAME_stand1=21, FRAME_stand30=0. firstframe=21, lastframe=0 -- that doesn't make sense unless
// the engine wraps. Let me re-read carefully.
// Actually FRAME_stand30 in the header = 0, and FRAME_stand1 = 21.
// So boss2_move_fidget = {21, 0, ...} which means firstframe > lastframe.
// This must be how the original engine handles it. We preserve it.
// The frame array has 30 entries.
// ============================================================

static BOSS2_FRAMES_FIDGET: [MFrame; 30] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static BOSS2_MOVE_FIDGET: MMove = MMove {
    firstframe: FRAME_STAND1,
    lastframe: FRAME_STAND30,
    frames: &BOSS2_FRAMES_FIDGET,
    endfunc: None,
};

// ============================================================
// Walk animation (FRAME_walk1 .. FRAME_walk20) - 20 frames
// ============================================================

static BOSS2_FRAMES_WALK: [MFrame; 20] = [
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
];

pub static BOSS2_MOVE_WALK: MMove = MMove {
    firstframe: FRAME_WALK1,
    lastframe: FRAME_WALK20,
    frames: &BOSS2_FRAMES_WALK,
    endfunc: None,
};

// ============================================================
// Run animation (FRAME_walk1 .. FRAME_walk20) - 20 frames
// ============================================================

static BOSS2_FRAMES_RUN: [MFrame; 20] = [
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
];

pub static BOSS2_MOVE_RUN: MMove = MMove {
    firstframe: FRAME_WALK1,
    lastframe: FRAME_WALK20,
    frames: &BOSS2_FRAMES_RUN,
    endfunc: None,
};

// ============================================================
// Attack: pre-machinegun (FRAME_attack1 .. FRAME_attack9) - 9 frames
// ============================================================

fn boss2_attack_mg_thinkfn(self_ent: &mut Edict, ctx: &mut GameContext) {
    boss2_attack_mg(self_ent, ctx);
}

static BOSS2_FRAMES_ATTACK_PRE_MG: [MFrame; 9] = [
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: Some(boss2_attack_mg_thinkfn) },
];

pub static BOSS2_MOVE_ATTACK_PRE_MG: MMove = MMove {
    firstframe: FRAME_ATTACK1,
    lastframe: FRAME_ATTACK9,
    frames: &BOSS2_FRAMES_ATTACK_PRE_MG,
    endfunc: None,
};

// ============================================================
// Attack: machinegun loop (FRAME_attack10 .. FRAME_attack15) - 6 frames
// ============================================================

fn boss2_reattack_mg_thinkfn(self_ent: &mut Edict, ctx: &mut GameContext) {
    boss2_reattack_mg(self_ent, ctx);
}

static BOSS2_FRAMES_ATTACK_MG: [MFrame; 6] = [
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: Some(boss2_machinegun) },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: Some(boss2_machinegun) },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: Some(boss2_machinegun) },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: Some(boss2_machinegun) },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: Some(boss2_machinegun) },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: Some(boss2_reattack_mg_thinkfn) },
];

pub static BOSS2_MOVE_ATTACK_MG: MMove = MMove {
    firstframe: FRAME_ATTACK10,
    lastframe: FRAME_ATTACK15,
    frames: &BOSS2_FRAMES_ATTACK_MG,
    endfunc: None,
};

// ============================================================
// Attack: post-machinegun (FRAME_attack16 .. FRAME_attack19) - 4 frames
// ============================================================

static BOSS2_FRAMES_ATTACK_POST_MG: [MFrame; 4] = [
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
];

pub static BOSS2_MOVE_ATTACK_POST_MG: MMove = MMove {
    firstframe: FRAME_ATTACK16,
    lastframe: FRAME_ATTACK19,
    frames: &BOSS2_FRAMES_ATTACK_POST_MG,
    endfunc: Some(boss2_run),
};

// ============================================================
// Attack: rocket (FRAME_attack20 .. FRAME_attack40) - 21 frames
// ============================================================

static BOSS2_FRAMES_ATTACK_ROCKET: [MFrame; 21] = [
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -20.0, think_fn: Some(boss2_rocket) },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0, think_fn: None },
];

pub static BOSS2_MOVE_ATTACK_ROCKET: MMove = MMove {
    firstframe: FRAME_ATTACK20,
    lastframe: FRAME_ATTACK40,
    frames: &BOSS2_FRAMES_ATTACK_ROCKET,
    endfunc: Some(boss2_run),
};

// ============================================================
// Pain: heavy (FRAME_pain2 .. FRAME_pain19) - 18 frames
// ============================================================

static BOSS2_FRAMES_PAIN_HEAVY: [MFrame; 18] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static BOSS2_MOVE_PAIN_HEAVY: MMove = MMove {
    firstframe: FRAME_PAIN2,
    lastframe: FRAME_PAIN19,
    frames: &BOSS2_FRAMES_PAIN_HEAVY,
    endfunc: Some(boss2_run),
};

// ============================================================
// Pain: light (FRAME_pain20 .. FRAME_pain23) - 4 frames
// ============================================================

static BOSS2_FRAMES_PAIN_LIGHT: [MFrame; 4] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static BOSS2_MOVE_PAIN_LIGHT: MMove = MMove {
    firstframe: FRAME_PAIN20,
    lastframe: FRAME_PAIN23,
    frames: &BOSS2_FRAMES_PAIN_LIGHT,
    endfunc: Some(boss2_run),
};

// ============================================================
// Death animation (FRAME_death2 .. FRAME_death50) - 49 frames
// ============================================================

static BOSS2_FRAMES_DEATH: [MFrame; 49] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(boss_explode) },
];

pub static BOSS2_MOVE_DEATH: MMove = MMove {
    firstframe: FRAME_DEATH2,
    lastframe: FRAME_DEATH50,
    frames: &BOSS2_FRAMES_DEATH,
    endfunc: Some(boss2_dead),
};

// ============================================================
// Behavior functions
// ============================================================

pub fn boss2_stand(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
}

pub fn boss2_run(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_RUN);
    }
}

pub fn boss2_walk(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_WALK);
}

pub fn boss2_attack(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let enemy_idx = self_ent.enemy;
    let enemy_origin = if enemy_idx >= 0 {
        _ctx.edicts[enemy_idx as usize].s.origin
    } else {
        [0.0; 3]
    };
    let vec = vector_subtract(&enemy_origin, &self_ent.s.origin);
    let range_val = vector_length(&vec);

    if range_val <= 125.0 {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_PRE_MG);
    } else if random() <= 0.6 {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_PRE_MG);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_ROCKET);
    }
}

pub fn boss2_attack_mg(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_MG);
}

pub fn boss2_reattack_mg(self_ent: &mut Edict, ctx: &mut GameContext) {
    let enemy_idx = self_ent.enemy;
    let enemy_infront = if enemy_idx >= 0 {
        infront(self_ent, &ctx.edicts[enemy_idx as usize])
    } else {
        false
    };
    if enemy_infront {
        if random() <= 0.7 {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_MG);
        } else {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_POST_MG);
        }
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK_POST_MG);
    }
}

pub fn boss2_pain(self_ent: &mut Edict, _other_idx: usize, _kick: f32, damage: i32, _ctx: &mut GameContext) {
    if self_ent.health < (self_ent.max_health / 2) {
        self_ent.s.skinnum = 1;
    }

    if _ctx.level.time < self_ent.pain_debounce_time {
        return;
    }

    self_ent.pain_debounce_time = _ctx.level.time + 3.0;

    // American wanted these at no attenuation
    if damage < 10 {
        let snd = SOUNDS.get().map_or(0, |s| s.pain3);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NONE, 0.0);
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN_LIGHT);
    } else if damage < 30 {
        let snd = SOUNDS.get().map_or(0, |s| s.pain1);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NONE, 0.0);
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN_LIGHT);
    } else {
        let snd = SOUNDS.get().map_or(0, |s| s.pain2);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NONE, 0.0);
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN_HEAVY);
    }
}

pub fn boss2_dead(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.mins = [-56.0, -56.0, 0.0];
    self_ent.maxs = [56.0, 56.0, 80.0];
    self_ent.movetype = MoveType::Toss;
    self_ent.svflags |= SVF_DEADMONSTER;
    self_ent.nextthink = 0.0;
    gi_linkentity(self_ent);
}

pub fn boss2_die(self_ent: &mut Edict, _inflictor_idx: usize, _attacker_idx: usize, _damage: i32, _point: [f32; 3], _ctx: &mut GameContext) {
    let snd = SOUNDS.get().map_or(0, |s| s.death);
    gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NONE, 0.0);
    self_ent.deadflag = DEAD_DEAD;
    self_ent.takedamage = DAMAGE_NO;
    self_ent.count = 0;
    self_ent.monsterinfo.currentmove = Some(MOVE_DEATH);
}

// ============================================================
// Boss2_CheckAttack
// ============================================================

pub fn boss2_check_attack(self_ent: &mut Edict, _ctx: &mut GameContext) -> bool {
    let enemy_idx = self_ent.enemy;
    if enemy_idx < 0 {
        return false;
    }
    let enemy = &_ctx.edicts[enemy_idx as usize];

    let _enemy_infront = infront(self_ent, enemy);
    let enemy_range = range(self_ent, enemy);
    let temp = vector_subtract(&enemy.s.origin, &self_ent.s.origin);
    let enemy_yaw = vectoyaw(&temp);

    self_ent.ideal_yaw = enemy_yaw;

    // melee attack
    if enemy_range == RANGE_MELEE {
        if self_ent.monsterinfo.melee_fn.is_some() {
            self_ent.monsterinfo.attack_state = AS_MELEE;
        } else {
            self_ent.monsterinfo.attack_state = AS_MISSILE;
        }
        return true;
    }

    // missile attack
    if self_ent.monsterinfo.attack_fn.is_none() {
        return false;
    }

    if _ctx.level.time < self_ent.monsterinfo.attack_finished {
        return false;
    }

    if enemy_range == RANGE_FAR {
        return false;
    }

    let chance: f32;
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        chance = 0.4;
    } else if enemy_range == RANGE_MELEE {
        chance = 0.8;
    } else if enemy_range == RANGE_NEAR {
        chance = 0.8;
    } else if enemy_range == RANGE_MID {
        chance = 0.8;
    } else {
        return false;
    }

    if random() < chance {
        self_ent.monsterinfo.attack_state = AS_MISSILE;
        self_ent.monsterinfo.attack_finished = _ctx.level.time + 2.0 * random();
        return true;
    }

    if self_ent.flags.intersects(FL_FLY) {
        if random() < 0.3 {
            self_ent.monsterinfo.attack_state = AS_SLIDING;
        } else {
            self_ent.monsterinfo.attack_state = AS_STRAIGHT;
        }
    }

    false
}

// ============================================================
// SP_monster_boss2 — entity spawn function
// ============================================================

pub fn sp_monster_boss2(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if _ctx.deathmatch != 0.0 {
        g_free_edict(self_ent);
        return;
    }

    SOUNDS.get_or_init(|| Boss2Sounds {
        pain1: gi_soundindex("bosshovr/bhvpain1.wav"),
        pain2: gi_soundindex("bosshovr/bhvpain2.wav"),
        pain3: gi_soundindex("bosshovr/bhvpain3.wav"),
        death: gi_soundindex("bosshovr/bhvdeth1.wav"),
        search1: gi_soundindex("bosshovr/bhvunqv1.wav"),
    });

    self_ent.s.sound = gi_soundindex("bosshovr/bhvengn1.wav");

    self_ent.movetype = MoveType::Step;
    self_ent.solid = Solid::Bbox;
    self_ent.s.modelindex = gi_modelindex("models/monsters/boss2/tris.md2");
    self_ent.mins = [-56.0, -56.0, 0.0];
    self_ent.maxs = [56.0, 56.0, 80.0];

    self_ent.health = 2000;
    self_ent.gib_health = -200;
    self_ent.mass = 1000;

    self_ent.flags |= FL_IMMUNE_LASER;

    self_ent.pain_fn = Some(crate::dispatch::PAIN_BOSS2);
    self_ent.die_fn = Some(crate::dispatch::DIE_BOSS2);

    self_ent.monsterinfo.stand_fn = Some(crate::dispatch::MSTAND_BOSS2);
    self_ent.monsterinfo.walk_fn = Some(crate::dispatch::MWALK_BOSS2);
    self_ent.monsterinfo.run_fn = Some(crate::dispatch::MRUN_BOSS2);
    self_ent.monsterinfo.attack_fn = Some(crate::dispatch::MATTACK_BOSS2);
    self_ent.monsterinfo.search_fn = Some(crate::dispatch::MSEARCH_BOSS2);
    self_ent.monsterinfo.checkattack_fn = Some(crate::dispatch::MCHECKATTACK_BOSS2);

    gi_linkentity(self_ent);

    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    self_ent.monsterinfo.scale = MODEL_SCALE;

    flymonster_start(self_ent);
}
