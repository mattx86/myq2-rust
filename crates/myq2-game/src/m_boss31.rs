// m_boss31.rs â€” Jorg (boss3) monster
// Converted from: myq2-original/game/m_boss31.c
// Frame definitions from: myq2-original/game/m_boss31.h

use crate::g_local::*;
use crate::game::*;
use myq2_common::common::frand as random;
use crate::entity_adapters::{gi_sound, gi_soundindex, gi_modelindex, gi_linkentity, g_free_edict, walkmonster_start, visible, g_project_source, monster_fire_bfg, monster_fire_bullet};

// ============================================================
// Frame definitions (from m_boss31.h)
// This file generated by ModelGen - Do NOT Modify
// G:\quake2\baseq2\models/monsters/boss3/jorg
// ============================================================

pub const FRAME_ATTAK101: i32 = 0;
pub const FRAME_ATTAK102: i32 = 1;
pub const FRAME_ATTAK103: i32 = 2;
pub const FRAME_ATTAK104: i32 = 3;
pub const FRAME_ATTAK105: i32 = 4;
pub const FRAME_ATTAK106: i32 = 5;
pub const FRAME_ATTAK107: i32 = 6;
pub const FRAME_ATTAK108: i32 = 7;
pub const FRAME_ATTAK109: i32 = 8;
pub const FRAME_ATTAK110: i32 = 9;
pub const FRAME_ATTAK111: i32 = 10;
pub const FRAME_ATTAK112: i32 = 11;
pub const FRAME_ATTAK113: i32 = 12;
pub const FRAME_ATTAK114: i32 = 13;
pub const FRAME_ATTAK115: i32 = 14;
pub const FRAME_ATTAK116: i32 = 15;
pub const FRAME_ATTAK117: i32 = 16;
pub const FRAME_ATTAK118: i32 = 17;
pub const FRAME_ATTAK201: i32 = 18;
pub const FRAME_ATTAK202: i32 = 19;
pub const FRAME_ATTAK203: i32 = 20;
pub const FRAME_ATTAK204: i32 = 21;
pub const FRAME_ATTAK205: i32 = 22;
pub const FRAME_ATTAK206: i32 = 23;
pub const FRAME_ATTAK207: i32 = 24;
pub const FRAME_ATTAK208: i32 = 25;
pub const FRAME_ATTAK209: i32 = 26;
pub const FRAME_ATTAK210: i32 = 27;
pub const FRAME_ATTAK211: i32 = 28;
pub const FRAME_ATTAK212: i32 = 29;
pub const FRAME_ATTAK213: i32 = 30;
pub const FRAME_DEATH01: i32 = 31;
pub const FRAME_DEATH02: i32 = 32;
pub const FRAME_DEATH03: i32 = 33;
pub const FRAME_DEATH04: i32 = 34;
pub const FRAME_DEATH05: i32 = 35;
pub const FRAME_DEATH06: i32 = 36;
pub const FRAME_DEATH07: i32 = 37;
pub const FRAME_DEATH08: i32 = 38;
pub const FRAME_DEATH09: i32 = 39;
pub const FRAME_DEATH10: i32 = 40;
pub const FRAME_DEATH11: i32 = 41;
pub const FRAME_DEATH12: i32 = 42;
pub const FRAME_DEATH13: i32 = 43;
pub const FRAME_DEATH14: i32 = 44;
pub const FRAME_DEATH15: i32 = 45;
pub const FRAME_DEATH16: i32 = 46;
pub const FRAME_DEATH17: i32 = 47;
pub const FRAME_DEATH18: i32 = 48;
pub const FRAME_DEATH19: i32 = 49;
pub const FRAME_DEATH20: i32 = 50;
pub const FRAME_DEATH21: i32 = 51;
pub const FRAME_DEATH22: i32 = 52;
pub const FRAME_DEATH23: i32 = 53;
pub const FRAME_DEATH24: i32 = 54;
pub const FRAME_DEATH25: i32 = 55;
pub const FRAME_DEATH26: i32 = 56;
pub const FRAME_DEATH27: i32 = 57;
pub const FRAME_DEATH28: i32 = 58;
pub const FRAME_DEATH29: i32 = 59;
pub const FRAME_DEATH30: i32 = 60;
pub const FRAME_DEATH31: i32 = 61;
pub const FRAME_DEATH32: i32 = 62;
pub const FRAME_DEATH33: i32 = 63;
pub const FRAME_DEATH34: i32 = 64;
pub const FRAME_DEATH35: i32 = 65;
pub const FRAME_DEATH36: i32 = 66;
pub const FRAME_DEATH37: i32 = 67;
pub const FRAME_DEATH38: i32 = 68;
pub const FRAME_DEATH39: i32 = 69;
pub const FRAME_DEATH40: i32 = 70;
pub const FRAME_DEATH41: i32 = 71;
pub const FRAME_DEATH42: i32 = 72;
pub const FRAME_DEATH43: i32 = 73;
pub const FRAME_DEATH44: i32 = 74;
pub const FRAME_DEATH45: i32 = 75;
pub const FRAME_DEATH46: i32 = 76;
pub const FRAME_DEATH47: i32 = 77;
pub const FRAME_DEATH48: i32 = 78;
pub const FRAME_DEATH49: i32 = 79;
pub const FRAME_DEATH50: i32 = 80;
pub const FRAME_PAIN101: i32 = 81;
pub const FRAME_PAIN102: i32 = 82;
pub const FRAME_PAIN103: i32 = 83;
pub const FRAME_PAIN201: i32 = 84;
pub const FRAME_PAIN202: i32 = 85;
pub const FRAME_PAIN203: i32 = 86;
pub const FRAME_PAIN301: i32 = 87;
pub const FRAME_PAIN302: i32 = 88;
pub const FRAME_PAIN303: i32 = 89;
pub const FRAME_PAIN304: i32 = 90;
pub const FRAME_PAIN305: i32 = 91;
pub const FRAME_PAIN306: i32 = 92;
pub const FRAME_PAIN307: i32 = 93;
pub const FRAME_PAIN308: i32 = 94;
pub const FRAME_PAIN309: i32 = 95;
pub const FRAME_PAIN310: i32 = 96;
pub const FRAME_PAIN311: i32 = 97;
pub const FRAME_PAIN312: i32 = 98;
pub const FRAME_PAIN313: i32 = 99;
pub const FRAME_PAIN314: i32 = 100;
pub const FRAME_PAIN315: i32 = 101;
pub const FRAME_PAIN316: i32 = 102;
pub const FRAME_PAIN317: i32 = 103;
pub const FRAME_PAIN318: i32 = 104;
pub const FRAME_PAIN319: i32 = 105;
pub const FRAME_PAIN320: i32 = 106;
pub const FRAME_PAIN321: i32 = 107;
pub const FRAME_PAIN322: i32 = 108;
pub const FRAME_PAIN323: i32 = 109;
pub const FRAME_PAIN324: i32 = 110;
pub const FRAME_PAIN325: i32 = 111;
pub const FRAME_STAND01: i32 = 112;
pub const FRAME_STAND02: i32 = 113;
pub const FRAME_STAND03: i32 = 114;
pub const FRAME_STAND04: i32 = 115;
pub const FRAME_STAND05: i32 = 116;
pub const FRAME_STAND06: i32 = 117;
pub const FRAME_STAND07: i32 = 118;
pub const FRAME_STAND08: i32 = 119;
pub const FRAME_STAND09: i32 = 120;
pub const FRAME_STAND10: i32 = 121;
pub const FRAME_STAND11: i32 = 122;
pub const FRAME_STAND12: i32 = 123;
pub const FRAME_STAND13: i32 = 124;
pub const FRAME_STAND14: i32 = 125;
pub const FRAME_STAND15: i32 = 126;
pub const FRAME_STAND16: i32 = 127;
pub const FRAME_STAND17: i32 = 128;
pub const FRAME_STAND18: i32 = 129;
pub const FRAME_STAND19: i32 = 130;
pub const FRAME_STAND20: i32 = 131;
pub const FRAME_STAND21: i32 = 132;
pub const FRAME_STAND22: i32 = 133;
pub const FRAME_STAND23: i32 = 134;
pub const FRAME_STAND24: i32 = 135;
pub const FRAME_STAND25: i32 = 136;
pub const FRAME_STAND26: i32 = 137;
pub const FRAME_STAND27: i32 = 138;
pub const FRAME_STAND28: i32 = 139;
pub const FRAME_STAND29: i32 = 140;
pub const FRAME_STAND30: i32 = 141;
pub const FRAME_STAND31: i32 = 142;
pub const FRAME_STAND32: i32 = 143;
pub const FRAME_STAND33: i32 = 144;
pub const FRAME_STAND34: i32 = 145;
pub const FRAME_STAND35: i32 = 146;
pub const FRAME_STAND36: i32 = 147;
pub const FRAME_STAND37: i32 = 148;
pub const FRAME_STAND38: i32 = 149;
pub const FRAME_STAND39: i32 = 150;
pub const FRAME_STAND40: i32 = 151;
pub const FRAME_STAND41: i32 = 152;
pub const FRAME_STAND42: i32 = 153;
pub const FRAME_STAND43: i32 = 154;
pub const FRAME_STAND44: i32 = 155;
pub const FRAME_STAND45: i32 = 156;
pub const FRAME_STAND46: i32 = 157;
pub const FRAME_STAND47: i32 = 158;
pub const FRAME_STAND48: i32 = 159;
pub const FRAME_STAND49: i32 = 160;
pub const FRAME_STAND50: i32 = 161;
pub const FRAME_STAND51: i32 = 162;
pub const FRAME_WALK01: i32 = 163;
pub const FRAME_WALK02: i32 = 164;
pub const FRAME_WALK03: i32 = 165;
pub const FRAME_WALK04: i32 = 166;
pub const FRAME_WALK05: i32 = 167;
pub const FRAME_WALK06: i32 = 168;
pub const FRAME_WALK07: i32 = 169;
pub const FRAME_WALK08: i32 = 170;
pub const FRAME_WALK09: i32 = 171;
pub const FRAME_WALK10: i32 = 172;
pub const FRAME_WALK11: i32 = 173;
pub const FRAME_WALK12: i32 = 174;
pub const FRAME_WALK13: i32 = 175;
pub const FRAME_WALK14: i32 = 176;
pub const FRAME_WALK15: i32 = 177;
pub const FRAME_WALK16: i32 = 178;
pub const FRAME_WALK17: i32 = 179;
pub const FRAME_WALK18: i32 = 180;
pub const FRAME_WALK19: i32 = 181;
pub const FRAME_WALK20: i32 = 182;
pub const FRAME_WALK21: i32 = 183;
pub const FRAME_WALK22: i32 = 184;
pub const FRAME_WALK23: i32 = 185;
pub const FRAME_WALK24: i32 = 186;
pub const FRAME_WALK25: i32 = 187;

pub const MODEL_SCALE: f32 = 1.0;

// ============================================================
// Sound channel / attenuation / content constants
// ============================================================

// CHAN_*, ATTN_* come from g_local::* re-export (myq2_common::q_shared)

use myq2_common::q_shared::{CONTENTS_SOLID, CONTENTS_MONSTER, CONTENTS_SLIME, CONTENTS_LAVA};

// DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD come from g_local::*

// MZ2 flash offsets used by Jorg
const MZ2_JORG_MACHINEGUN_L1: usize = 120;
const MZ2_JORG_MACHINEGUN_R1: usize = 126;
const MZ2_JORG_BFG_1: usize = 132;

// AS_* attack state constants come from g_local::*

// ============================================================

use crate::ai_wrappers::{ai_stand, ai_walk, ai_run, ai_charge, ai_move};

// ============================================================
// Sound indices (module-level state, replaces C statics)
// ============================================================

#[derive(Default)]
pub struct JorgSounds {
    pub pain1: i32,
    pub pain2: i32,
    pub pain3: i32,
    pub idle: i32,
    pub death: i32,
    pub search1: i32,
    pub search2: i32,
    pub search3: i32,
    pub attack1: i32,
    pub attack2: i32,
    pub firegun: i32,
    pub step_left: i32,
    pub step_right: i32,
    pub death_hit: i32,
}

static SOUNDS: std::sync::OnceLock<JorgSounds> = std::sync::OnceLock::new();

use crate::g_ai::{infront, range};
use crate::g_utils::vectoyaw;

use myq2_common::q_shared::angle_vectors;

use myq2_common::q_shared::{
    vector_subtract as vec_subtract, vector_normalize as vec_normalize,
    vector_length as vec_length, vector_ma as vec_ma,
};

fn boss_explode(self_ent: &mut Edict, ctx: &mut GameContext) {
    // BossExplode: create multiple explosions on the entity during death sequence.
    // In the original C this spawns temp entities. For now, a simplified version.
    let origin = self_ent.s.origin;
    crate::game_import::gi_write_byte(SVC_TEMP_ENTITY as i32);
    crate::game_import::gi_write_byte(TE_EXPLOSION1 as i32);
    crate::game_import::gi_write_position(&origin);
    crate::game_import::gi_multicast(&origin, MULTICAST_PVS);
}

use crate::m_boss32::{makron_toss, makron_precache};


// ============================================================
// Jorg behavior functions
// ============================================================

pub fn jorg_search(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let r = random();

    let (s1, s2, s3) = SOUNDS.get().map_or((0, 0, 0), |s| (s.search1, s.search2, s.search3));

    if r <= 0.3 {
        gi_sound(self_ent, CHAN_VOICE, s1, 1.0, ATTN_NORM, 0.0);
    } else if r <= 0.6 {
        gi_sound(self_ent, CHAN_VOICE, s2, 1.0, ATTN_NORM, 0.0);
    } else {
        gi_sound(self_ent, CHAN_VOICE, s3, 1.0, ATTN_NORM, 0.0);
    }
}

pub fn jorg_idle(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let snd = SOUNDS.get().map_or(0, |s| s.idle);
    gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
}

pub fn jorg_death_hit(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let snd = SOUNDS.get().map_or(0, |s| s.death_hit);
    gi_sound(self_ent, CHAN_BODY, snd, 1.0, ATTN_NORM, 0.0);
}

pub fn jorg_step_left(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let snd = SOUNDS.get().map_or(0, |s| s.step_left);
    gi_sound(self_ent, CHAN_BODY, snd, 1.0, ATTN_NORM, 0.0);
}

pub fn jorg_step_right(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let snd = SOUNDS.get().map_or(0, |s| s.step_right);
    gi_sound(self_ent, CHAN_BODY, snd, 1.0, ATTN_NORM, 0.0);
}

// ============================================================
// Stand animation
// ============================================================

pub static JORG_FRAMES_STAND: [MFrame; 51] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: Some(jorg_idle) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },       // 10
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },       // 20
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },       // 30
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 19.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 11.0, think_fn: Some(jorg_step_left) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 9.0, think_fn: Some(jorg_step_right) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },       // 40
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -17.0, think_fn: Some(jorg_step_left) },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -12.0, think_fn: None },     // 50
    MFrame { ai_fn: ai_stand, dist: -14.0, think_fn: Some(jorg_step_right) }, // 51
];

// Move table index constants
pub const JORG_MOVE_STAND_IDX: usize = 0;
pub const JORG_MOVE_WALK_IDX: usize = 1;
pub const JORG_MOVE_RUN_IDX: usize = 2;
pub const JORG_MOVE_ATTACK1_IDX: usize = 3;
pub const JORG_MOVE_ATTACK2_IDX: usize = 4;
pub const JORG_MOVE_START_ATTACK1_IDX: usize = 5;
pub const JORG_MOVE_END_ATTACK1_IDX: usize = 6;
pub const JORG_MOVE_PAIN1_IDX: usize = 7;
pub const JORG_MOVE_PAIN2_IDX: usize = 8;
pub const JORG_MOVE_PAIN3_IDX: usize = 9;
pub const JORG_MOVE_DEATH_IDX: usize = 10;

pub static JORG_MOVE_STAND: MMove = MMove {
    firstframe: FRAME_STAND01,
    lastframe: FRAME_STAND51,
    frames: &JORG_FRAMES_STAND,
    endfunc: None,
};

pub fn jorg_stand(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(JORG_MOVE_STAND_IDX);
}

// ============================================================
// Run animation
// ============================================================

pub static JORG_FRAMES_RUN: [MFrame; 14] = [
    MFrame { ai_fn: ai_run, dist: 17.0, think_fn: Some(jorg_step_left) },
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 12.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 33.0, think_fn: Some(jorg_step_right) },
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 9.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 9.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 9.0, think_fn: None },
];

pub static JORG_MOVE_RUN: MMove = MMove {
    firstframe: FRAME_WALK06,
    lastframe: FRAME_WALK19,
    frames: &JORG_FRAMES_RUN,
    endfunc: None,
};

// ============================================================
// Walk animation
// ============================================================

pub static JORG_FRAMES_START_WALK: [MFrame; 5] = [
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 7.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 9.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 15.0, think_fn: None },
];

pub static JORG_MOVE_START_WALK: MMove = MMove {
    firstframe: FRAME_WALK01,
    lastframe: FRAME_WALK05,
    frames: &JORG_FRAMES_START_WALK,
    endfunc: None,
};

pub static JORG_FRAMES_WALK: [MFrame; 14] = [
    MFrame { ai_fn: ai_walk, dist: 17.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 12.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 33.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 9.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 9.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 9.0, think_fn: None },
];

pub static JORG_MOVE_WALK: MMove = MMove {
    firstframe: FRAME_WALK06,
    lastframe: FRAME_WALK19,
    frames: &JORG_FRAMES_WALK,
    endfunc: None,
};

pub static JORG_FRAMES_END_WALK: [MFrame; 6] = [
    MFrame { ai_fn: ai_walk, dist: 11.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: -8.0, think_fn: None },
];

pub static JORG_MOVE_END_WALK: MMove = MMove {
    firstframe: FRAME_WALK20,
    lastframe: FRAME_WALK25,
    frames: &JORG_FRAMES_END_WALK,
    endfunc: None,
};

pub fn jorg_walk(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(JORG_MOVE_WALK_IDX);
}

pub fn jorg_run(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        self_ent.monsterinfo.currentmove = Some(JORG_MOVE_STAND_IDX);
    } else {
        self_ent.monsterinfo.currentmove = Some(JORG_MOVE_RUN_IDX);
    }
}

// ============================================================
// Pain animations
// ============================================================

pub static JORG_FRAMES_PAIN3: [MFrame; 25] = [
    MFrame { ai_fn: ai_move, dist: -28.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -6.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: Some(jorg_step_left) },
    MFrame { ai_fn: ai_move, dist: -9.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(jorg_step_right) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -7.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -11.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -4.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 11.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 7.0, think_fn: Some(jorg_step_left) },
    MFrame { ai_fn: ai_move, dist: 17.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(jorg_step_right) },
];

pub static JORG_MOVE_PAIN3: MMove = MMove {
    firstframe: FRAME_PAIN301,
    lastframe: FRAME_PAIN325,
    frames: &JORG_FRAMES_PAIN3,
    endfunc: Some(jorg_run),
};

pub static JORG_FRAMES_PAIN2: [MFrame; 3] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static JORG_MOVE_PAIN2: MMove = MMove {
    firstframe: FRAME_PAIN201,
    lastframe: FRAME_PAIN203,
    frames: &JORG_FRAMES_PAIN2,
    endfunc: Some(jorg_run),
};

pub static JORG_FRAMES_PAIN1: [MFrame; 3] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static JORG_MOVE_PAIN1: MMove = MMove {
    firstframe: FRAME_PAIN101,
    lastframe: FRAME_PAIN103,
    frames: &JORG_FRAMES_PAIN1,
    endfunc: Some(jorg_run),
};

// ============================================================
// Death animation
// ============================================================

pub static JORG_FRAMES_DEATH1: [MFrame; 50] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },       // 10
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },       // 20
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },       // 30
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },       // 40
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(makron_toss) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: Some(boss_explode) },  // 50
];

pub static JORG_MOVE_DEATH: MMove = MMove {
    firstframe: FRAME_DEATH01,
    lastframe: FRAME_DEATH50,
    frames: &JORG_FRAMES_DEATH1,
    endfunc: Some(jorg_dead),
};

// ============================================================
// Attack animations
// ============================================================

pub static JORG_FRAMES_ATTACK2: [MFrame; 13] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(jorg_bfg) },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static JORG_MOVE_ATTACK2: MMove = MMove {
    firstframe: FRAME_ATTAK201,
    lastframe: FRAME_ATTAK213,
    frames: &JORG_FRAMES_ATTACK2,
    endfunc: Some(jorg_run),
};

pub static JORG_FRAMES_START_ATTACK1: [MFrame; 8] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: None },
];

pub static JORG_MOVE_START_ATTACK1: MMove = MMove {
    firstframe: FRAME_ATTAK101,
    lastframe: FRAME_ATTAK108,
    frames: &JORG_FRAMES_START_ATTACK1,
    endfunc: Some(jorg_attack1),
};

pub static JORG_FRAMES_ATTACK1: [MFrame; 6] = [
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(jorg_firebullet) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(jorg_firebullet) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(jorg_firebullet) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(jorg_firebullet) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(jorg_firebullet) },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(jorg_firebullet) },
];

pub static JORG_MOVE_ATTACK1: MMove = MMove {
    firstframe: FRAME_ATTAK109,
    lastframe: FRAME_ATTAK114,
    frames: &JORG_FRAMES_ATTACK1,
    endfunc: Some(jorg_reattack1),
};

pub static JORG_FRAMES_END_ATTACK1: [MFrame; 4] = [
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0, think_fn: None },
];

pub static JORG_MOVE_END_ATTACK1: MMove = MMove {
    firstframe: FRAME_ATTAK115,
    lastframe: FRAME_ATTAK118,
    frames: &JORG_FRAMES_END_ATTACK1,
    endfunc: Some(jorg_run),
};

// ============================================================
// Attack behavior functions
// ============================================================

pub fn jorg_reattack1(self_ent: &mut Edict, ctx: &mut GameContext) {
    // Check if enemy is visible and decide whether to continue firing
    if self_ent.enemy >= 0 {
        let enemy_idx = self_ent.enemy as usize;
        let enemy = &ctx.edicts[enemy_idx];
        // Placeholder: visible check
        if visible(self_ent, enemy) {
            if random() < 0.9 {
                self_ent.monsterinfo.currentmove = Some(JORG_MOVE_ATTACK1_IDX);
            } else {
                self_ent.s.sound = 0;
                self_ent.monsterinfo.currentmove = Some(JORG_MOVE_END_ATTACK1_IDX);
            }
        } else {
            self_ent.s.sound = 0;
            self_ent.monsterinfo.currentmove = Some(JORG_MOVE_END_ATTACK1_IDX);
        }
    } else {
        self_ent.s.sound = 0;
        self_ent.monsterinfo.currentmove = Some(JORG_MOVE_END_ATTACK1_IDX);
    }
}

pub fn jorg_attack1(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(JORG_MOVE_ATTACK1_IDX);
}

// ============================================================
// Pain
// ============================================================

pub fn jorg_pain(self_ent: &mut Edict, _other_index: Option<usize>, _kick: f32, damage: i32, ctx: &mut GameContext) {
    if self_ent.health < (self_ent.max_health / 2) {
        self_ent.s.skinnum = 1;
    }

    self_ent.s.sound = 0;

    if ctx.level.time < self_ent.pain_debounce_time {
        return;
    }

    // Lessen the chance of him going into his pain frames if he takes little damage
    if damage <= 40
        && random() <= 0.6 {
            return;
        }

    // If he's entering his attack1 or using attack1, lessen the chance of him going into pain
    if self_ent.s.frame >= FRAME_ATTAK101 && self_ent.s.frame <= FRAME_ATTAK108
        && random() <= 0.005 {
            return;
        }

    if self_ent.s.frame >= FRAME_ATTAK109 && self_ent.s.frame <= FRAME_ATTAK114
        && random() <= 0.00005 {
            return;
        }

    if self_ent.s.frame >= FRAME_ATTAK201 && self_ent.s.frame <= FRAME_ATTAK208
        && random() <= 0.005 {
            return;
        }

    self_ent.pain_debounce_time = ctx.level.time + 3.0;
    if ctx.skill == 3.0 {
        return; // no pain anims in nightmare
    }

    let (s1, s2, s3) = SOUNDS.get().map_or((0, 0, 0), |s| (s.pain1, s.pain2, s.pain3));

    if damage <= 50 {
        gi_sound(self_ent, CHAN_VOICE, s1, 1.0, ATTN_NORM, 0.0);
        self_ent.monsterinfo.currentmove = Some(JORG_MOVE_PAIN1_IDX);
    } else if damage <= 100 {
        gi_sound(self_ent, CHAN_VOICE, s2, 1.0, ATTN_NORM, 0.0);
        self_ent.monsterinfo.currentmove = Some(JORG_MOVE_PAIN2_IDX);
    } else if random() <= 0.3 {
        gi_sound(self_ent, CHAN_VOICE, s3, 1.0, ATTN_NORM, 0.0);
        self_ent.monsterinfo.currentmove = Some(JORG_MOVE_PAIN3_IDX);
    }
}

// ============================================================
// BFG attack
// ============================================================

pub fn jorg_bfg(self_ent: &mut Edict, ctx: &mut GameContext) {
    let mut forward = [0.0f32; 3];
    let mut right = [0.0f32; 3];
    let mut start = [0.0f32; 3];

    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
    let flash_ofs = crate::entity_adapters::monster_flash_offset(MZ2_JORG_BFG_1 as i32);
    g_project_source(&self_ent.s.origin, &flash_ofs, &forward, &right, &mut start);

    if self_ent.enemy >= 0 {
        let enemy_idx = self_ent.enemy as usize;
        let enemy = &ctx.edicts[enemy_idx];
        let mut vec = enemy.s.origin;
        vec[2] += enemy.viewheight as f32;
        let mut dir = vec_subtract(&vec, &start);
        vec_normalize(&mut dir);

        let snd = SOUNDS.get().map_or(0, |s| s.attack2);
        gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
        monster_fire_bfg(self_ent, start, dir, 50, 300, 100, 200.0, MZ2_JORG_BFG_1 as i32);
    }
}

// ============================================================
// Machinegun attacks
// ============================================================

pub fn jorg_firebullet_right(self_ent: &mut Edict, ctx: &mut GameContext) {
    let mut forward = [0.0f32; 3];
    let mut right = [0.0f32; 3];
    let mut start = [0.0f32; 3];

    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
    let flash_ofs = crate::entity_adapters::monster_flash_offset(MZ2_JORG_MACHINEGUN_R1 as i32);
    g_project_source(&self_ent.s.origin, &flash_ofs, &forward, &right, &mut start);

    if self_ent.enemy >= 0 {
        let enemy_idx = self_ent.enemy as usize;
        let enemy = &ctx.edicts[enemy_idx];
        let mut target = vec_ma(&enemy.s.origin, -0.2, &enemy.velocity);
        target[2] += enemy.viewheight as f32;
        forward = vec_subtract(&target, &start);
        vec_normalize(&mut forward);

        monster_fire_bullet(self_ent, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_JORG_MACHINEGUN_R1 as i32);
    }
}

pub fn jorg_firebullet_left(self_ent: &mut Edict, ctx: &mut GameContext) {
    let mut forward = [0.0f32; 3];
    let mut right = [0.0f32; 3];
    let mut start = [0.0f32; 3];

    angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
    let flash_ofs = crate::entity_adapters::monster_flash_offset(MZ2_JORG_MACHINEGUN_L1 as i32);
    g_project_source(&self_ent.s.origin, &flash_ofs, &forward, &right, &mut start);

    if self_ent.enemy >= 0 {
        let enemy_idx = self_ent.enemy as usize;
        let enemy = &ctx.edicts[enemy_idx];
        let mut target = vec_ma(&enemy.s.origin, -0.2, &enemy.velocity);
        target[2] += enemy.viewheight as f32;
        forward = vec_subtract(&target, &start);
        vec_normalize(&mut forward);

        monster_fire_bullet(self_ent, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_JORG_MACHINEGUN_L1 as i32);
    }
}

pub fn jorg_firebullet(self_ent: &mut Edict, ctx: &mut GameContext) {
    jorg_firebullet_left(self_ent, ctx);
    jorg_firebullet_right(self_ent, ctx);
}

// ============================================================
// Attack decision
// ============================================================

pub fn jorg_attack(self_ent: &mut Edict, ctx: &mut GameContext) {
    if self_ent.enemy >= 0 {
        let enemy_idx = self_ent.enemy as usize;
        let enemy = &ctx.edicts[enemy_idx];
        let vec = vec_subtract(&enemy.s.origin, &self_ent.s.origin);
        let _range = vec_length(&vec);

        let (s_attack1, s_attack2) = SOUNDS.get().map_or((0, 0), |s| (s.attack1, s.attack2));

        if random() <= 0.75 {
            gi_sound(self_ent, CHAN_VOICE, s_attack1, 1.0, ATTN_NORM, 0.0);
            self_ent.s.sound = gi_soundindex("boss3/w_loop.wav");
            self_ent.monsterinfo.currentmove = Some(JORG_MOVE_START_ATTACK1_IDX);
        } else {
            gi_sound(self_ent, CHAN_VOICE, s_attack2, 1.0, ATTN_NORM, 0.0);
            self_ent.monsterinfo.currentmove = Some(JORG_MOVE_ATTACK2_IDX);
        }
    }
}

// ============================================================
// Death
// ============================================================

pub fn jorg_dead(_self_ent: &mut Edict, _ctx: &mut GameContext) {
    // In the original C code, this function body is #if 0'd out.
    // The Makron spawn was handled differently. Keeping as no-op.
}

pub fn jorg_die(self_ent: &mut Edict, _inflictor_index: Option<usize>, _attacker_index: Option<usize>, _damage: i32, _point: [f32; 3], _ctx: &mut GameContext) {
    let snd = SOUNDS.get().map_or(0, |s| s.death);
    gi_sound(self_ent, CHAN_VOICE, snd, 1.0, ATTN_NORM, 0.0);
    self_ent.deadflag = DEAD_DEAD;
    self_ent.takedamage = Damage::No as i32;
    self_ent.s.sound = 0;
    self_ent.count = 0;
    self_ent.monsterinfo.currentmove = Some(JORG_MOVE_DEATH_IDX);
}

// ============================================================
// Check attack
// ============================================================

pub fn jorg_check_attack(self_ent: &mut Edict, ctx: &mut GameContext) -> bool {
    if self_ent.enemy < 0 {
        return false;
    }
    let enemy_idx = self_ent.enemy as usize;

    let enemy = &ctx.edicts[enemy_idx];

    if enemy.health > 0 {
        // See if any entities are in the way of the shot
        let mut spot1 = self_ent.s.origin;
        spot1[2] += self_ent.viewheight as f32;
        let mut spot2 = enemy.s.origin;
        spot2[2] += enemy.viewheight as f32;

        let self_idx = self_ent.s.number as usize;
        let tr = crate::game_import::gi_trace(
            &spot1,
            &[0.0; 3],
            &[0.0; 3],
            &spot2,
            self_idx as i32,
            CONTENTS_SOLID | CONTENTS_MONSTER | CONTENTS_SLIME | CONTENTS_LAVA,
        );

        // do we have a clear shot?
        if tr.ent_index != enemy_idx as i32 {
            return false;
        }
    }

    let _enemy_infront = infront(self_ent, enemy);
    let enemy_range = range(self_ent, enemy);
    let temp = vec_subtract(&enemy.s.origin, &self_ent.s.origin);
    let enemy_yaw = vectoyaw(&temp);

    self_ent.ideal_yaw = enemy_yaw;

    // melee attack
    if enemy_range == RANGE_MELEE {
        if self_ent.monsterinfo.melee_fn.is_some() {
            self_ent.monsterinfo.attack_state = AS_MELEE;
        } else {
            self_ent.monsterinfo.attack_state = AS_MISSILE;
        }
        return true;
    }

    // missile attack
    if self_ent.monsterinfo.attack_fn.is_none() {
        return false;
    }

    if ctx.level.time < self_ent.monsterinfo.attack_finished {
        return false;
    }

    if enemy_range == RANGE_FAR {
        return false;
    }

    let chance: f32;
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        chance = 0.4;
    } else if enemy_range == RANGE_MELEE {
        chance = 0.8;
    } else if enemy_range == RANGE_NEAR {
        chance = 0.4;
    } else if enemy_range == RANGE_MID {
        chance = 0.2;
    } else {
        return false;
    }

    if random() < chance {
        self_ent.monsterinfo.attack_state = AS_MISSILE;
        self_ent.monsterinfo.attack_finished = ctx.level.time + 2.0 * random();
        return true;
    }

    if self_ent.flags.intersects(FL_FLY) {
        if random() < 0.3 {
            self_ent.monsterinfo.attack_state = AS_SLIDING;
        } else {
            self_ent.monsterinfo.attack_state = AS_STRAIGHT;
        }
    }

    false
}

// ============================================================
// Spawn function
// ============================================================

/// QUAKED monster_jorg (1 .5 0) (-80 -80 0) (90 90 140) Ambush Trigger_Spawn Sight
pub fn sp_monster_jorg(self_ent: &mut Edict, ctx: &mut GameContext) {
    if ctx.deathmatch != 0.0 {
        g_free_edict(self_ent);
        return;
    }

    SOUNDS.get_or_init(|| JorgSounds {
        pain1: gi_soundindex("boss3/bs3pain1.wav"),
        pain2: gi_soundindex("boss3/bs3pain2.wav"),
        pain3: gi_soundindex("boss3/bs3pain3.wav"),
        death: gi_soundindex("boss3/bs3deth1.wav"),
        attack1: gi_soundindex("boss3/bs3atck1.wav"),
        attack2: gi_soundindex("boss3/bs3atck2.wav"),
        search1: gi_soundindex("boss3/bs3srch1.wav"),
        search2: gi_soundindex("boss3/bs3srch2.wav"),
        search3: gi_soundindex("boss3/bs3srch3.wav"),
        idle: gi_soundindex("boss3/bs3idle1.wav"),
        step_left: gi_soundindex("boss3/step1.wav"),
        step_right: gi_soundindex("boss3/step2.wav"),
        firegun: gi_soundindex("boss3/xfire.wav"),
        death_hit: gi_soundindex("boss3/d_hit.wav"),
    });

    makron_precache();

    self_ent.movetype = MoveType::Step;
    self_ent.solid = Solid::Bbox;
    self_ent.s.modelindex = gi_modelindex("models/monsters/boss3/rider/tris.md2");
    self_ent.s.modelindex2 = gi_modelindex("models/monsters/boss3/jorg/tris.md2");
    self_ent.mins = [-80.0, -80.0, 0.0];
    self_ent.maxs = [80.0, 80.0, 140.0];

    self_ent.health = 3000;
    self_ent.gib_health = -2000;
    self_ent.mass = 1000;

    self_ent.pain_fn = Some(crate::dispatch::PAIN_JORG);
    self_ent.die_fn = Some(crate::dispatch::DIE_JORG);

    self_ent.monsterinfo.stand_fn = Some(crate::dispatch::MSTAND_JORG);
    self_ent.monsterinfo.walk_fn = Some(crate::dispatch::MWALK_JORG);
    self_ent.monsterinfo.run_fn = Some(crate::dispatch::MRUN_JORG);
    self_ent.monsterinfo.dodge_fn = None;
    self_ent.monsterinfo.attack_fn = Some(crate::dispatch::MATTACK_JORG);
    self_ent.monsterinfo.search_fn = Some(crate::dispatch::MSEARCH_JORG);
    self_ent.monsterinfo.melee_fn = None;
    self_ent.monsterinfo.sight_fn = None;
    self_ent.monsterinfo.checkattack_fn = Some(crate::dispatch::MCHECKATTACK_JORG);

    gi_linkentity(self_ent);

    self_ent.monsterinfo.currentmove = Some(JORG_MOVE_STAND_IDX);
    self_ent.monsterinfo.scale = MODEL_SCALE;

    walkmonster_start(self_ent);
}
