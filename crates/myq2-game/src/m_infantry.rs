// m_infantry.rs â€” Infantry monster
// Converted from: myq2-original/game/m_infantry.c
// Frame definitions from: myq2-original/game/m_infantry.h

use crate::g_local::*;
use crate::game::*;
use crate::game_import::skill_value;
use myq2_common::common::{frand as random, rand_i32};
use myq2_common::q_shared::{vector_ma_to, vector_subtract_to, vector_normalize};

// ============================================================
// Frame definitions (from m_infantry.h)
// This file generated by ModelGen - Do NOT Modify
// ============================================================

pub const FRAME_GUN02: i32 = 0;
pub const FRAME_STAND01: i32 = 1;
pub const FRAME_STAND02: i32 = 2;
pub const FRAME_STAND03: i32 = 3;
pub const FRAME_STAND04: i32 = 4;
pub const FRAME_STAND05: i32 = 5;
pub const FRAME_STAND06: i32 = 6;
pub const FRAME_STAND07: i32 = 7;
pub const FRAME_STAND08: i32 = 8;
pub const FRAME_STAND09: i32 = 9;
pub const FRAME_STAND10: i32 = 10;
pub const FRAME_STAND11: i32 = 11;
pub const FRAME_STAND12: i32 = 12;
pub const FRAME_STAND13: i32 = 13;
pub const FRAME_STAND14: i32 = 14;
pub const FRAME_STAND15: i32 = 15;
pub const FRAME_STAND16: i32 = 16;
pub const FRAME_STAND17: i32 = 17;
pub const FRAME_STAND18: i32 = 18;
pub const FRAME_STAND19: i32 = 19;
pub const FRAME_STAND20: i32 = 20;
pub const FRAME_STAND21: i32 = 21;
pub const FRAME_STAND22: i32 = 22;
pub const FRAME_STAND23: i32 = 23;
pub const FRAME_STAND24: i32 = 24;
pub const FRAME_STAND25: i32 = 25;
pub const FRAME_STAND26: i32 = 26;
pub const FRAME_STAND27: i32 = 27;
pub const FRAME_STAND28: i32 = 28;
pub const FRAME_STAND29: i32 = 29;
pub const FRAME_STAND30: i32 = 30;
pub const FRAME_STAND31: i32 = 31;
pub const FRAME_STAND32: i32 = 32;
pub const FRAME_STAND33: i32 = 33;
pub const FRAME_STAND34: i32 = 34;
pub const FRAME_STAND35: i32 = 35;
pub const FRAME_STAND36: i32 = 36;
pub const FRAME_STAND37: i32 = 37;
pub const FRAME_STAND38: i32 = 38;
pub const FRAME_STAND39: i32 = 39;
pub const FRAME_STAND40: i32 = 40;
pub const FRAME_STAND41: i32 = 41;
pub const FRAME_STAND42: i32 = 42;
pub const FRAME_STAND43: i32 = 43;
pub const FRAME_STAND44: i32 = 44;
pub const FRAME_STAND45: i32 = 45;
pub const FRAME_STAND46: i32 = 46;
pub const FRAME_STAND47: i32 = 47;
pub const FRAME_STAND48: i32 = 48;
pub const FRAME_STAND49: i32 = 49;
pub const FRAME_STAND50: i32 = 50;
pub const FRAME_STAND51: i32 = 51;
pub const FRAME_STAND52: i32 = 52;
pub const FRAME_STAND53: i32 = 53;
pub const FRAME_STAND54: i32 = 54;
pub const FRAME_STAND55: i32 = 55;
pub const FRAME_STAND56: i32 = 56;
pub const FRAME_STAND57: i32 = 57;
pub const FRAME_STAND58: i32 = 58;
pub const FRAME_STAND59: i32 = 59;
pub const FRAME_STAND60: i32 = 60;
pub const FRAME_STAND61: i32 = 61;
pub const FRAME_STAND62: i32 = 62;
pub const FRAME_STAND63: i32 = 63;
pub const FRAME_STAND64: i32 = 64;
pub const FRAME_STAND65: i32 = 65;
pub const FRAME_STAND66: i32 = 66;
pub const FRAME_STAND67: i32 = 67;
pub const FRAME_STAND68: i32 = 68;
pub const FRAME_STAND69: i32 = 69;
pub const FRAME_STAND70: i32 = 70;
pub const FRAME_STAND71: i32 = 71;
pub const FRAME_WALK01: i32 = 72;
pub const FRAME_WALK02: i32 = 73;
pub const FRAME_WALK03: i32 = 74;
pub const FRAME_WALK04: i32 = 75;
pub const FRAME_WALK05: i32 = 76;
pub const FRAME_WALK06: i32 = 77;
pub const FRAME_WALK07: i32 = 78;
pub const FRAME_WALK08: i32 = 79;
pub const FRAME_WALK09: i32 = 80;
pub const FRAME_WALK10: i32 = 81;
pub const FRAME_WALK11: i32 = 82;
pub const FRAME_WALK12: i32 = 83;
pub const FRAME_WALK13: i32 = 84;
pub const FRAME_WALK14: i32 = 85;
pub const FRAME_WALK15: i32 = 86;
pub const FRAME_WALK16: i32 = 87;
pub const FRAME_WALK17: i32 = 88;
pub const FRAME_WALK18: i32 = 89;
pub const FRAME_WALK19: i32 = 90;
pub const FRAME_WALK20: i32 = 91;
pub const FRAME_RUN01: i32 = 92;
pub const FRAME_RUN02: i32 = 93;
pub const FRAME_RUN03: i32 = 94;
pub const FRAME_RUN04: i32 = 95;
pub const FRAME_RUN05: i32 = 96;
pub const FRAME_RUN06: i32 = 97;
pub const FRAME_RUN07: i32 = 98;
pub const FRAME_RUN08: i32 = 99;
pub const FRAME_PAIN101: i32 = 100;
pub const FRAME_PAIN102: i32 = 101;
pub const FRAME_PAIN103: i32 = 102;
pub const FRAME_PAIN104: i32 = 103;
pub const FRAME_PAIN105: i32 = 104;
pub const FRAME_PAIN106: i32 = 105;
pub const FRAME_PAIN107: i32 = 106;
pub const FRAME_PAIN108: i32 = 107;
pub const FRAME_PAIN109: i32 = 108;
pub const FRAME_PAIN110: i32 = 109;
pub const FRAME_PAIN201: i32 = 110;
pub const FRAME_PAIN202: i32 = 111;
pub const FRAME_PAIN203: i32 = 112;
pub const FRAME_PAIN204: i32 = 113;
pub const FRAME_PAIN205: i32 = 114;
pub const FRAME_PAIN206: i32 = 115;
pub const FRAME_PAIN207: i32 = 116;
pub const FRAME_PAIN208: i32 = 117;
pub const FRAME_PAIN209: i32 = 118;
pub const FRAME_PAIN210: i32 = 119;
pub const FRAME_DUCK01: i32 = 120;
pub const FRAME_DUCK02: i32 = 121;
pub const FRAME_DUCK03: i32 = 122;
pub const FRAME_DUCK04: i32 = 123;
pub const FRAME_DUCK05: i32 = 124;
pub const FRAME_DEATH101: i32 = 125;
pub const FRAME_DEATH102: i32 = 126;
pub const FRAME_DEATH103: i32 = 127;
pub const FRAME_DEATH104: i32 = 128;
pub const FRAME_DEATH105: i32 = 129;
pub const FRAME_DEATH106: i32 = 130;
pub const FRAME_DEATH107: i32 = 131;
pub const FRAME_DEATH108: i32 = 132;
pub const FRAME_DEATH109: i32 = 133;
pub const FRAME_DEATH110: i32 = 134;
pub const FRAME_DEATH111: i32 = 135;
pub const FRAME_DEATH112: i32 = 136;
pub const FRAME_DEATH113: i32 = 137;
pub const FRAME_DEATH114: i32 = 138;
pub const FRAME_DEATH115: i32 = 139;
pub const FRAME_DEATH116: i32 = 140;
pub const FRAME_DEATH117: i32 = 141;
pub const FRAME_DEATH118: i32 = 142;
pub const FRAME_DEATH119: i32 = 143;
pub const FRAME_DEATH120: i32 = 144;
pub const FRAME_DEATH201: i32 = 145;
pub const FRAME_DEATH202: i32 = 146;
pub const FRAME_DEATH203: i32 = 147;
pub const FRAME_DEATH204: i32 = 148;
pub const FRAME_DEATH205: i32 = 149;
pub const FRAME_DEATH206: i32 = 150;
pub const FRAME_DEATH207: i32 = 151;
pub const FRAME_DEATH208: i32 = 152;
pub const FRAME_DEATH209: i32 = 153;
pub const FRAME_DEATH210: i32 = 154;
pub const FRAME_DEATH211: i32 = 155;
pub const FRAME_DEATH212: i32 = 156;
pub const FRAME_DEATH213: i32 = 157;
pub const FRAME_DEATH214: i32 = 158;
pub const FRAME_DEATH215: i32 = 159;
pub const FRAME_DEATH216: i32 = 160;
pub const FRAME_DEATH217: i32 = 161;
pub const FRAME_DEATH218: i32 = 162;
pub const FRAME_DEATH219: i32 = 163;
pub const FRAME_DEATH220: i32 = 164;
pub const FRAME_DEATH221: i32 = 165;
pub const FRAME_DEATH222: i32 = 166;
pub const FRAME_DEATH223: i32 = 167;
pub const FRAME_DEATH224: i32 = 168;
pub const FRAME_DEATH225: i32 = 169;
pub const FRAME_DEATH301: i32 = 170;
pub const FRAME_DEATH302: i32 = 171;
pub const FRAME_DEATH303: i32 = 172;
pub const FRAME_DEATH304: i32 = 173;
pub const FRAME_DEATH305: i32 = 174;
pub const FRAME_DEATH306: i32 = 175;
pub const FRAME_DEATH307: i32 = 176;
pub const FRAME_DEATH308: i32 = 177;
pub const FRAME_DEATH309: i32 = 178;
pub const FRAME_BLOCK01: i32 = 179;
pub const FRAME_BLOCK02: i32 = 180;
pub const FRAME_BLOCK03: i32 = 181;
pub const FRAME_BLOCK04: i32 = 182;
pub const FRAME_BLOCK05: i32 = 183;
pub const FRAME_ATTAK101: i32 = 184;
pub const FRAME_ATTAK102: i32 = 185;
pub const FRAME_ATTAK103: i32 = 186;
pub const FRAME_ATTAK104: i32 = 187;
pub const FRAME_ATTAK105: i32 = 188;
pub const FRAME_ATTAK106: i32 = 189;
pub const FRAME_ATTAK107: i32 = 190;
pub const FRAME_ATTAK108: i32 = 191;
pub const FRAME_ATTAK109: i32 = 192;
pub const FRAME_ATTAK110: i32 = 193;
pub const FRAME_ATTAK111: i32 = 194;
pub const FRAME_ATTAK112: i32 = 195;
pub const FRAME_ATTAK113: i32 = 196;
pub const FRAME_ATTAK114: i32 = 197;
pub const FRAME_ATTAK115: i32 = 198;
pub const FRAME_ATTAK201: i32 = 199;
pub const FRAME_ATTAK202: i32 = 200;
pub const FRAME_ATTAK203: i32 = 201;
pub const FRAME_ATTAK204: i32 = 202;
pub const FRAME_ATTAK205: i32 = 203;
pub const FRAME_ATTAK206: i32 = 204;
pub const FRAME_ATTAK207: i32 = 205;
pub const FRAME_ATTAK208: i32 = 206;

pub const MODEL_SCALE: f32 = 1.0;

// ============================================================
// Sound channel / attenuation constants (mirrors C defines)
// ============================================================

// CHAN_*, ATTN_* come from g_local::* re-export (myq2_common::q_shared)

// ============================================================

use crate::ai_wrappers::{ai_stand, ai_walk, ai_run, ai_charge, ai_move};
use crate::entity_adapters::{
    gi_sound, gi_soundindex, gi_modelindex, gi_linkentity,
    g_free_edict, walkmonster_start, throw_gib, throw_head,
    monster_flash_offset, g_project_source, range,
    fire_hit, monster_fire_bullet,
};

// ============================================================
// Sound indices (module-level state, replaces C statics)
// ============================================================

#[derive(Default)]
pub struct InfantrySounds {
    pub pain1: i32,
    pub pain2: i32,
    pub die1: i32,
    pub die2: i32,
    pub gunshot: i32,
    pub weapon_cock: i32,
    pub punch_swing: i32,
    pub punch_hit: i32,
    pub sight: i32,
    pub search: i32,
    pub idle: i32,
}

static SOUNDS: std::sync::OnceLock<InfantrySounds> = std::sync::OnceLock::new();

fn m_fly_check(self_ent: &mut Edict) {
    let self_idx = self_ent.s.number as i32;
    crate::g_local::with_global_game_ctx(|ctx| {
        crate::g_monster::m_fly_check(ctx, self_idx);
    });
}


use myq2_common::q_shared::angle_vectors;


// ============================================================
// Constants from C code
// ============================================================

const MZ2_INFANTRY_MACHINEGUN_1: i32 = 34; // from q_shared.h
const MZ2_INFANTRY_MACHINEGUN_2: i32 = 35;
// DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, RANGE_MELEE come from g_local::*

// ============================================================
// Move indices for monsterinfo.currentmove
// ============================================================

pub const MOVE_STAND: usize = 0;
pub const MOVE_FIDGET: usize = 1;
pub const MOVE_WALK: usize = 2;
pub const MOVE_RUN: usize = 3;
pub const MOVE_PAIN1: usize = 4;
pub const MOVE_PAIN2: usize = 5;
pub const MOVE_DEATH1: usize = 6;
pub const MOVE_DEATH2: usize = 7;
pub const MOVE_DEATH3: usize = 8;
pub const MOVE_DUCK: usize = 9;
pub const MOVE_ATTACK1: usize = 10;
pub const MOVE_ATTACK2: usize = 11;

// ============================================================
// Aim angles table (used in InfantryMachineGun)
// ============================================================

static AIMANGLES: [[f32; 3]; 12] = [
    [0.0, 5.0, 0.0],
    [10.0, 15.0, 0.0],
    [20.0, 25.0, 0.0],
    [25.0, 35.0, 0.0],
    [30.0, 40.0, 0.0],
    [30.0, 45.0, 0.0],
    [25.0, 50.0, 0.0],
    [20.0, 40.0, 0.0],
    [15.0, 35.0, 0.0],
    [40.0, 35.0, 0.0],
    [70.0, 35.0, 0.0],
    [90.0, 35.0, 0.0],
];


// ============================================================
// InfantryMachineGun
// ============================================================

fn infantry_machine_gun(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let mut start = [0.0_f32; 3];
    let _target = [0.0_f32; 3];
    let mut forward = [0.0_f32; 3];
    let mut right = [0.0_f32; 3];
    let mut vec = [0.0_f32; 3];

    if self_ent.s.frame == FRAME_ATTAK111 {
        let flash_number = MZ2_INFANTRY_MACHINEGUN_1;
        angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
        let flash_ofs = monster_flash_offset(flash_number);
        g_project_source(&self_ent.s.origin, &flash_ofs, &forward, &right, &mut start);

        let enemy_idx = self_ent.enemy;
        if enemy_idx > 0 && (enemy_idx as usize) < _ctx.edicts.len() {
            let enemy = &_ctx.edicts[enemy_idx as usize];
            let mut target = [0.0_f32; 3];
            vector_ma_to(&enemy.s.origin, -0.2, &enemy.velocity, &mut target);
            target[2] += enemy.viewheight as f32;
            vector_subtract_to(&target, &start, &mut forward);
            vector_normalize(&mut forward);
        } else {
            angle_vectors(&self_ent.s.angles, Some(&mut forward), None, None);
        }

        monster_fire_bullet(self_ent, start, forward, 3, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
    } else {
        let flash_number = MZ2_INFANTRY_MACHINEGUN_2 + (self_ent.s.frame - FRAME_DEATH211);

        angle_vectors(&self_ent.s.angles, Some(&mut forward), Some(&mut right), None);
        let flash_ofs = monster_flash_offset(flash_number);
        g_project_source(&self_ent.s.origin, &flash_ofs, &forward, &right, &mut start);

        // VectorSubtract(self->s.angles, aimangles[flash_number - MZ2_INFANTRY_MACHINEGUN_2], vec);
        let aim_idx = (flash_number - MZ2_INFANTRY_MACHINEGUN_2) as usize;
        vector_subtract_to(&self_ent.s.angles, &AIMANGLES[aim_idx], &mut vec);
        angle_vectors(&vec, Some(&mut forward), None, None);

        monster_fire_bullet(self_ent, start, forward, 3, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
    }
}

// ============================================================
// Stand animation
// ============================================================

static INFANTRY_FRAMES_STAND: [MFrame; 22] = [
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0, think_fn: None },
];

pub static INFANTRY_MOVE_STAND: MMove = MMove {
    firstframe: FRAME_STAND50,
    lastframe: FRAME_STAND71,
    frames: &INFANTRY_FRAMES_STAND,
    endfunc: None,
};

pub fn infantry_stand(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
}

// ============================================================
// Fidget animation
// ============================================================

static INFANTRY_FRAMES_FIDGET: [MFrame; 49] = [
    MFrame { ai_fn: ai_stand, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 3.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 6.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 3.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_stand, dist: -2.0, think_fn: None },
];

pub static INFANTRY_MOVE_FIDGET: MMove = MMove {
    firstframe: FRAME_STAND01,
    lastframe: FRAME_STAND49,
    frames: &INFANTRY_FRAMES_FIDGET,
    endfunc: Some(infantry_stand),
};

pub fn infantry_fidget(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_FIDGET);
    let sound_idle = SOUNDS.get().map_or(0, |s| s.idle);
    gi_sound(self_ent, CHAN_VOICE, sound_idle, 1.0, ATTN_IDLE, 0.0);
}

// ============================================================
// Walk animation
// ============================================================

static INFANTRY_FRAMES_WALK: [MFrame; 12] = [
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 4.0, think_fn: None },
    MFrame { ai_fn: ai_walk, dist: 5.0, think_fn: None },
];

pub static INFANTRY_MOVE_WALK: MMove = MMove {
    firstframe: FRAME_WALK03,
    lastframe: FRAME_WALK14,
    frames: &INFANTRY_FRAMES_WALK,
    endfunc: None,
};

pub fn infantry_walk(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.currentmove = Some(MOVE_WALK);
}

// ============================================================
// Run animation
// ============================================================

static INFANTRY_FRAMES_RUN: [MFrame; 8] = [
    MFrame { ai_fn: ai_run, dist: 10.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 20.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 5.0,  think_fn: None },
    MFrame { ai_fn: ai_run, dist: 7.0,  think_fn: None },
    MFrame { ai_fn: ai_run, dist: 30.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 35.0, think_fn: None },
    MFrame { ai_fn: ai_run, dist: 2.0,  think_fn: None },
    MFrame { ai_fn: ai_run, dist: 6.0,  think_fn: None },
];

pub static INFANTRY_MOVE_RUN: MMove = MMove {
    firstframe: FRAME_RUN01,
    lastframe: FRAME_RUN08,
    frames: &INFANTRY_FRAMES_RUN,
    endfunc: None,
};

pub fn infantry_run(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_STAND_GROUND) {
        self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_RUN);
    }
}

// ============================================================
// Pain animations
// ============================================================

static INFANTRY_FRAMES_PAIN1: [MFrame; 10] = [
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 6.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0,  think_fn: None },
];

pub static INFANTRY_MOVE_PAIN1: MMove = MMove {
    firstframe: FRAME_PAIN101,
    lastframe: FRAME_PAIN110,
    frames: &INFANTRY_FRAMES_PAIN1,
    endfunc: Some(infantry_run),
};

static INFANTRY_FRAMES_PAIN2: [MFrame; 10] = [
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 5.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0,  think_fn: None },
];

pub static INFANTRY_MOVE_PAIN2: MMove = MMove {
    firstframe: FRAME_PAIN201,
    lastframe: FRAME_PAIN210,
    frames: &INFANTRY_FRAMES_PAIN2,
    endfunc: Some(infantry_run),
};

pub fn infantry_pain(self_ent: &mut Edict, _other: &mut Edict, _kick: f32, _damage: i32, ctx: &mut GameContext) {
    if self_ent.health < (self_ent.max_health / 2) {
        self_ent.s.skinnum = 1;
    }

    if ctx.level.time < self_ent.pain_debounce_time {
        return;
    }

    self_ent.pain_debounce_time = ctx.level.time + 3.0;

    // skill->value == 3 means nightmare: no pain anims
    if skill_value() == 3.0 {
        return; // no pain anims in nightmare
    }

    let n = rand_i32() % 2;
    if n == 0 {
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN1);
        let sound_pain1 = SOUNDS.get().map_or(0, |s| s.pain1);
        gi_sound(self_ent, CHAN_VOICE, sound_pain1, 1.0, ATTN_NORM, 0.0);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_PAIN2);
        let sound_pain2 = SOUNDS.get().map_or(0, |s| s.pain2);
        gi_sound(self_ent, CHAN_VOICE, sound_pain2, 1.0, ATTN_NORM, 0.0);
    }
}

// ============================================================
// Sight
// ============================================================

pub fn infantry_sight(self_ent: &mut Edict, _other: &mut Edict) {
    let sound_sight = SOUNDS.get().map_or(0, |s| s.sight);
    gi_sound(self_ent, CHAN_BODY, sound_sight, 1.0, ATTN_NORM, 0.0);
}

// ============================================================
// Death
// ============================================================

fn infantry_dead(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.mins = [-16.0, -16.0, -24.0];
    self_ent.maxs = [16.0, 16.0, -8.0];
    self_ent.movetype = MoveType::Toss;
    self_ent.svflags |= SVF_DEADMONSTER;
    gi_linkentity(self_ent);

    m_fly_check(self_ent);
}

static INFANTRY_FRAMES_DEATH1: [MFrame; 20] = [
    MFrame { ai_fn: ai_move, dist: -4.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -4.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 2.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 9.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 9.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 5.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0, think_fn: None },
];

pub static INFANTRY_MOVE_DEATH1: MMove = MMove {
    firstframe: FRAME_DEATH101,
    lastframe: FRAME_DEATH120,
    frames: &INFANTRY_FRAMES_DEATH1,
    endfunc: Some(infantry_dead),
};

// Off with his head
static INFANTRY_FRAMES_DEATH2: [MFrame; 25] = [
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 5.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: -1.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 1.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 4.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 3.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: -2.0,  think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: -2.0,  think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: -3.0,  think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: -1.0,  think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: -2.0,  think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: 2.0,   think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: 2.0,   think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: 3.0,   think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: -10.0, think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: -7.0,  think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: -8.0,  think_fn: Some(infantry_machine_gun) },
    MFrame { ai_fn: ai_move, dist: -6.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 4.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: None },
];

pub static INFANTRY_MOVE_DEATH2: MMove = MMove {
    firstframe: FRAME_DEATH201,
    lastframe: FRAME_DEATH225,
    frames: &INFANTRY_FRAMES_DEATH2,
    endfunc: Some(infantry_dead),
};

static INFANTRY_FRAMES_DEATH3: [MFrame; 9] = [
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: -6.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: -11.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: -3.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: -11.0, think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: None },
    MFrame { ai_fn: ai_move, dist: 0.0,   think_fn: None },
];

pub static INFANTRY_MOVE_DEATH3: MMove = MMove {
    firstframe: FRAME_DEATH301,
    lastframe: FRAME_DEATH309,
    frames: &INFANTRY_FRAMES_DEATH3,
    endfunc: Some(infantry_dead),
};

pub fn infantry_die(self_ent: &mut Edict, _inflictor: &mut Edict, _attacker: &mut Edict, damage: i32, _point: [f32; 3], _ctx: &mut GameContext) {
    // check for gib
    if self_ent.health <= self_ent.gib_health {
        gi_sound(self_ent, CHAN_VOICE, gi_soundindex("misc/udeath.wav"), 1.0, ATTN_NORM, 0.0);
        for _ in 0..2 {
            throw_gib(self_ent, "models/objects/gibs/bone/tris.md2", damage, GIB_ORGANIC);
        }
        for _ in 0..4 {
            throw_gib(self_ent, "models/objects/gibs/sm_meat/tris.md2", damage, GIB_ORGANIC);
        }
        throw_head(self_ent, "models/objects/gibs/head2/tris.md2", damage, GIB_ORGANIC);
        self_ent.deadflag = DEAD_DEAD;
        return;
    }

    if self_ent.deadflag == DEAD_DEAD {
        return;
    }

    // regular death
    self_ent.deadflag = DEAD_DEAD;
    self_ent.takedamage = Damage::Yes as i32;

    let n = rand_i32() % 3;
    if n == 0 {
        self_ent.monsterinfo.currentmove = Some(MOVE_DEATH1);
        let sound_die2 = SOUNDS.get().map_or(0, |s| s.die2);
        gi_sound(self_ent, CHAN_VOICE, sound_die2, 1.0, ATTN_NORM, 0.0);
    } else if n == 1 {
        self_ent.monsterinfo.currentmove = Some(MOVE_DEATH2);
        let sound_die1 = SOUNDS.get().map_or(0, |s| s.die1);
        gi_sound(self_ent, CHAN_VOICE, sound_die1, 1.0, ATTN_NORM, 0.0);
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_DEATH3);
        let sound_die2 = SOUNDS.get().map_or(0, |s| s.die2);
        gi_sound(self_ent, CHAN_VOICE, sound_die2, 1.0, ATTN_NORM, 0.0);
    }
}

// ============================================================
// Duck (dodge) animation
// ============================================================

fn infantry_duck_down(self_ent: &mut Edict, _ctx: &mut GameContext) {
    if self_ent.monsterinfo.aiflags.intersects(AI_DUCKED) {
        return;
    }
    self_ent.monsterinfo.aiflags |= AI_DUCKED;
    self_ent.maxs[2] -= 32.0;
    self_ent.takedamage = Damage::Yes as i32;
    self_ent.monsterinfo.pausetime = _ctx.level.time + 1.0;
    gi_linkentity(self_ent);
}

fn infantry_duck_hold(self_ent: &mut Edict, ctx: &mut GameContext) {
    if ctx.level.time >= self_ent.monsterinfo.pausetime {
        self_ent.monsterinfo.aiflags &= !AI_HOLD_FRAME;
    } else {
        self_ent.monsterinfo.aiflags |= AI_HOLD_FRAME;
    }
}

fn infantry_duck_up(self_ent: &mut Edict, _ctx: &mut GameContext) {
    self_ent.monsterinfo.aiflags &= !AI_DUCKED;
    self_ent.maxs[2] += 32.0;
    self_ent.takedamage = Damage::Aim as i32;
    gi_linkentity(self_ent);
}

static INFANTRY_FRAMES_DUCK: [MFrame; 5] = [
    MFrame { ai_fn: ai_move, dist: -2.0, think_fn: Some(infantry_duck_down) },
    MFrame { ai_fn: ai_move, dist: -5.0, think_fn: Some(infantry_duck_hold) },
    MFrame { ai_fn: ai_move, dist: 3.0,  think_fn: None },
    MFrame { ai_fn: ai_move, dist: 4.0,  think_fn: Some(infantry_duck_up) },
    MFrame { ai_fn: ai_move, dist: 0.0,  think_fn: None },
];

pub static INFANTRY_MOVE_DUCK: MMove = MMove {
    firstframe: FRAME_DUCK01,
    lastframe: FRAME_DUCK05,
    frames: &INFANTRY_FRAMES_DUCK,
    endfunc: Some(infantry_run),
};

pub fn infantry_dodge(self_ent: &mut Edict, _attacker: &mut Edict, _eta: f32, _ctx: &mut GameContext) {
    if random() > 0.25 {
        return;
    }

    if self_ent.enemy <= 0 {
        self_ent.enemy = _attacker.s.number;
    }

    self_ent.monsterinfo.currentmove = Some(MOVE_DUCK);
}

// ============================================================
// Attack 1: machinegun
// ============================================================

fn infantry_cock_gun(self_ent: &mut Edict, ctx: &mut GameContext) {
    let sound_weapon_cock = SOUNDS.get().map_or(0, |s| s.weapon_cock);
    gi_sound(self_ent, CHAN_WEAPON, sound_weapon_cock, 1.0, ATTN_NORM, 0.0);
    let n = (rand_i32() & 15) + 3 + 7;
    self_ent.monsterinfo.pausetime = ctx.level.time + (n as f32) * FRAMETIME;
}

fn infantry_fire(self_ent: &mut Edict, ctx: &mut GameContext) {
    infantry_machine_gun(self_ent, ctx);

    if ctx.level.time >= self_ent.monsterinfo.pausetime {
        self_ent.monsterinfo.aiflags &= !AI_HOLD_FRAME;
    } else {
        self_ent.monsterinfo.aiflags |= AI_HOLD_FRAME;
    }
}

static INFANTRY_FRAMES_ATTACK1: [MFrame; 15] = [
    MFrame { ai_fn: ai_charge, dist: 4.0,  think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0,  think_fn: Some(infantry_cock_gun) },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0,  think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 2.0,  think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 1.0,  think_fn: Some(infantry_fire) },
    MFrame { ai_fn: ai_charge, dist: 5.0,  think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -1.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -2.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: -3.0, think_fn: None },
];

pub static INFANTRY_MOVE_ATTACK1: MMove = MMove {
    firstframe: FRAME_ATTAK101,
    lastframe: FRAME_ATTAK115,
    frames: &INFANTRY_FRAMES_ATTACK1,
    endfunc: Some(infantry_run),
};

// ============================================================
// Attack 2: melee (punch)
// ============================================================

fn infantry_swing(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let sound_punch_swing = SOUNDS.get().map_or(0, |s| s.punch_swing);
    gi_sound(self_ent, CHAN_WEAPON, sound_punch_swing, 1.0, ATTN_NORM, 0.0);
}

fn infantry_smack(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let aim: [f32; 3] = [MELEE_DISTANCE, 0.0, 0.0];
    if fire_hit(self_ent, &aim, 5 + (rand_i32() % 5), 50) {
        let sound_punch_hit = SOUNDS.get().map_or(0, |s| s.punch_hit);
        gi_sound(self_ent, CHAN_WEAPON, sound_punch_hit, 1.0, ATTN_NORM, 0.0);
    }
}

static INFANTRY_FRAMES_ATTACK2: [MFrame; 8] = [
    MFrame { ai_fn: ai_charge, dist: 3.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 0.0, think_fn: Some(infantry_swing) },
    MFrame { ai_fn: ai_charge, dist: 8.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 5.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 8.0, think_fn: Some(infantry_smack) },
    MFrame { ai_fn: ai_charge, dist: 6.0, think_fn: None },
    MFrame { ai_fn: ai_charge, dist: 3.0, think_fn: None },
];

pub static INFANTRY_MOVE_ATTACK2: MMove = MMove {
    firstframe: FRAME_ATTAK201,
    lastframe: FRAME_ATTAK208,
    frames: &INFANTRY_FRAMES_ATTACK2,
    endfunc: Some(infantry_run),
};

pub fn infantry_attack(self_ent: &mut Edict, _ctx: &mut GameContext) {
    let enemy_idx = self_ent.enemy;
    if enemy_idx > 0 && (enemy_idx as usize) < _ctx.edicts.len() {
        let enemy = &_ctx.edicts[enemy_idx as usize];
        if range(self_ent, enemy) == RANGE_MELEE {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK2);
        } else {
            self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK1);
        }
    } else {
        self_ent.monsterinfo.currentmove = Some(MOVE_ATTACK1);
    }
}

// ============================================================
// Spawn function
// ============================================================

/// QUAKED monster_infantry (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
pub fn sp_monster_infantry(self_ent: &mut Edict, ctx: &mut GameContext) {
    if ctx.deathmatch != 0.0 {
        g_free_edict(self_ent);
        return;
    }

    // Pre-caches
    SOUNDS.get_or_init(|| InfantrySounds {
        pain1: gi_soundindex("infantry/infpain1.wav"),
        pain2: gi_soundindex("infantry/infpain2.wav"),
        die1: gi_soundindex("infantry/infdeth1.wav"),
        die2: gi_soundindex("infantry/infdeth2.wav"),
        gunshot: gi_soundindex("infantry/infatck1.wav"),
        weapon_cock: gi_soundindex("infantry/infatck3.wav"),
        punch_swing: gi_soundindex("infantry/infatck2.wav"),
        punch_hit: gi_soundindex("infantry/melee2.wav"),
        sight: gi_soundindex("infantry/infsght1.wav"),
        search: gi_soundindex("infantry/infsrch1.wav"),
        idle: gi_soundindex("infantry/infidle1.wav"),
    });

    self_ent.movetype = MoveType::Step;
    self_ent.solid = Solid::Bbox;
    self_ent.s.modelindex = gi_modelindex("models/monsters/infantry/tris.md2");
    self_ent.mins = [-16.0, -16.0, -24.0];
    self_ent.maxs = [16.0, 16.0, 32.0];

    self_ent.health = 100;
    self_ent.gib_health = -40;
    self_ent.mass = 200;

    // Function callbacks stored as indices into dispatch tables
    self_ent.pain_fn = Some(crate::dispatch::PAIN_INFANTRY);
    self_ent.die_fn = Some(crate::dispatch::DIE_INFANTRY);

    self_ent.monsterinfo.stand_fn = Some(crate::dispatch::MSTAND_INFANTRY);
    self_ent.monsterinfo.walk_fn = Some(crate::dispatch::MWALK_INFANTRY);
    self_ent.monsterinfo.run_fn = Some(crate::dispatch::MRUN_INFANTRY);
    self_ent.monsterinfo.dodge_fn = Some(crate::dispatch::MDODGE_INFANTRY);
    self_ent.monsterinfo.attack_fn = Some(crate::dispatch::MATTACK_INFANTRY);
    self_ent.monsterinfo.melee_fn = None;
    self_ent.monsterinfo.sight_fn = Some(crate::dispatch::MSIGHT_INFANTRY);
    self_ent.monsterinfo.idle_fn = Some(crate::dispatch::MIDLE_INFANTRY);

    gi_linkentity(self_ent);

    self_ent.monsterinfo.currentmove = Some(MOVE_STAND);
    self_ent.monsterinfo.scale = MODEL_SCALE;

    walkmonster_start(self_ent);
}

// ============================================================
// Move table: maps move indices to MMove statics
// ============================================================

/// Returns the MMove for a given infantry move index.
pub fn infantry_get_move(index: usize) -> Option<&'static MMove> {
    match index {
        MOVE_STAND => Some(&INFANTRY_MOVE_STAND),
        MOVE_FIDGET => Some(&INFANTRY_MOVE_FIDGET),
        MOVE_WALK => Some(&INFANTRY_MOVE_WALK),
        MOVE_RUN => Some(&INFANTRY_MOVE_RUN),
        MOVE_PAIN1 => Some(&INFANTRY_MOVE_PAIN1),
        MOVE_PAIN2 => Some(&INFANTRY_MOVE_PAIN2),
        MOVE_DEATH1 => Some(&INFANTRY_MOVE_DEATH1),
        MOVE_DEATH2 => Some(&INFANTRY_MOVE_DEATH2),
        MOVE_DEATH3 => Some(&INFANTRY_MOVE_DEATH3),
        MOVE_DUCK => Some(&INFANTRY_MOVE_DUCK),
        MOVE_ATTACK1 => Some(&INFANTRY_MOVE_ATTACK1),
        MOVE_ATTACK2 => Some(&INFANTRY_MOVE_ATTACK2),
        _ => None,
    }
}
